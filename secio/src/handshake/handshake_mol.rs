// Generated by Molecule 0.2.5

use molecule::faster_hex::hex_string;
use molecule::prelude::{Entity as _, Reader as _};
#[derive(Clone)]
pub struct Secp256k1(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct Secp256k1Reader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Secp256k1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for Secp256k1Reader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Secp256k1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for Secp256k1Reader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
#[derive(Debug, Default)]
pub struct Secp256k1Builder(pub(crate) Vec<u8>);
impl molecule::prelude::Entity for Secp256k1 {
    type Builder = Secp256k1Builder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Secp256k1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Secp256k1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for Secp256k1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Secp256k1::new_unchecked(v.into())
    }
}
impl Secp256k1 {
    pub const NAME: &'static str = "Secp256k1";
    pub fn as_reader<'r>(&'r self) -> Secp256k1Reader<'r> {
        Secp256k1Reader::new_unchecked(self.as_slice())
    }
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice_from(4)
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl<'r> molecule::prelude::Reader<'r> for Secp256k1Reader<'r> {
    type Entity = Secp256k1;
    fn to_entity(&self) -> Self::Entity {
        Secp256k1::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Secp256k1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let item_count = u32::from_le(ptr[0]) as usize;
        let expected = 4 + 1 * item_count;
        if len != expected {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), expected, len);
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> Secp256k1Reader<'r> {
    pub const NAME: &'r str = "Secp256k1Reader";
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[4..]
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl molecule::prelude::Builder for Secp256k1Builder {
    type Entity = Secp256k1;
    fn expected_length(&self) -> usize {
        4 + 1 * self.0.len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.0.len() as u32).to_le_bytes();
        writer.write_all(&len)?;
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Secp256k1::new_unchecked(inner.into())
    }
}
impl Secp256k1Builder {
    pub const NAME: &'static str = "Secp256k1Builder";
    pub fn set(mut self, v: Vec<u8>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: u8) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = u8>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct Secp256k1Iterator(Secp256k1, usize, usize);
impl ::std::iter::Iterator for Secp256k1Iterator {
    type Item = u8;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for Secp256k1Iterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for Secp256k1 {
    type Item = u8;
    type IntoIter = Secp256k1Iterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        Secp256k1Iterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct Bytes(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct BytesReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Bytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for BytesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Bytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for BytesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
#[derive(Debug, Default)]
pub struct BytesBuilder(pub(crate) Vec<u8>);
impl molecule::prelude::Entity for Bytes {
    type Builder = BytesBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bytes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for Bytes {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Bytes::new_unchecked(v.into())
    }
}
impl Bytes {
    pub const NAME: &'static str = "Bytes";
    pub fn as_reader<'r>(&'r self) -> BytesReader<'r> {
        BytesReader::new_unchecked(self.as_slice())
    }
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice_from(4)
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesReader<'r> {
    type Entity = Bytes;
    fn to_entity(&self) -> Self::Entity {
        Bytes::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let item_count = u32::from_le(ptr[0]) as usize;
        let expected = 4 + 1 * item_count;
        if len != expected {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), expected, len);
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> BytesReader<'r> {
    pub const NAME: &'r str = "BytesReader";
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[4..]
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl molecule::prelude::Builder for BytesBuilder {
    type Entity = Bytes;
    fn expected_length(&self) -> usize {
        4 + 1 * self.0.len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.0.len() as u32).to_le_bytes();
        writer.write_all(&len)?;
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Bytes::new_unchecked(inner.into())
    }
}
impl BytesBuilder {
    pub const NAME: &'static str = "BytesBuilder";
    pub fn set(mut self, v: Vec<u8>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: u8) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = u8>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct BytesIterator(Bytes, usize, usize);
impl ::std::iter::Iterator for BytesIterator {
    type Item = u8;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for BytesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for Bytes {
    type Item = u8;
    type IntoIter = BytesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct String(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct StringReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for StringReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for StringReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
#[derive(Debug, Default)]
pub struct StringBuilder(pub(crate) Vec<u8>);
impl molecule::prelude::Entity for String {
    type Builder = StringBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        String(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StringReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for String {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        String::new_unchecked(v.into())
    }
}
impl String {
    pub const NAME: &'static str = "String";
    pub fn as_reader<'r>(&'r self) -> StringReader<'r> {
        StringReader::new_unchecked(self.as_slice())
    }
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice_from(4)
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl<'r> molecule::prelude::Reader<'r> for StringReader<'r> {
    type Entity = String;
    fn to_entity(&self) -> Self::Entity {
        String::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StringReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let item_count = u32::from_le(ptr[0]) as usize;
        let expected = 4 + 1 * item_count;
        if len != expected {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), expected, len);
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> StringReader<'r> {
    pub const NAME: &'r str = "StringReader";
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[4..]
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl molecule::prelude::Builder for StringBuilder {
    type Entity = String;
    fn expected_length(&self) -> usize {
        4 + 1 * self.0.len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.0.len() as u32).to_le_bytes();
        writer.write_all(&len)?;
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        String::new_unchecked(inner.into())
    }
}
impl StringBuilder {
    pub const NAME: &'static str = "StringBuilder";
    pub fn set(mut self, v: Vec<u8>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: u8) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = u8>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct StringIterator(String, usize, usize);
impl ::std::iter::Iterator for StringIterator {
    type Item = u8;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for StringIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for String {
    type Item = u8;
    type IntoIter = StringIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        StringIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct PublicKey(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct PublicKeyReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for PublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for PublicKeyReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for PublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> ::std::fmt::Display for PublicKeyReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
#[derive(Debug, Clone)]
pub enum PublicKeyUnion {
    NotSet,
    Secp256k1(Secp256k1),
}
#[derive(Debug, Clone, Copy)]
pub enum PublicKeyUnionReader<'r> {
    NotSet,
    Secp256k1(Secp256k1Reader<'r>),
}
impl ::std::default::Default for PublicKeyUnion {
    fn default() -> Self {
        PublicKeyUnion::Secp256k1(::std::default::Default::default())
    }
}
impl ::std::fmt::Display for PublicKeyUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            PublicKeyUnion::Secp256k1(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Secp256k1::NAME, item)
            }
            PublicKeyUnion::NotSet => write!(f, "NotSet"),
        }
    }
}
impl<'r> ::std::fmt::Display for PublicKeyUnionReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            PublicKeyUnionReader::Secp256k1(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Secp256k1::NAME, item)
            }
            PublicKeyUnionReader::NotSet => write!(f, "NotSet"),
        }
    }
}
impl PublicKeyUnion {
    pub(crate) fn display_inner(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            PublicKeyUnion::Secp256k1(ref item) => write!(f, "{}", item),
            PublicKeyUnion::NotSet => write!(f, "NotSet"),
        }
    }
}
impl<'r> PublicKeyUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            PublicKeyUnionReader::Secp256k1(ref item) => write!(f, "{}", item),
            PublicKeyUnionReader::NotSet => write!(f, "NotSet"),
        }
    }
}
impl ::std::convert::From<Secp256k1> for PublicKeyUnion {
    fn from(item: Secp256k1) -> Self {
        PublicKeyUnion::Secp256k1(item)
    }
}
impl<'r> ::std::convert::From<Secp256k1Reader<'r>> for PublicKeyUnionReader<'r> {
    fn from(item: Secp256k1Reader<'r>) -> Self {
        PublicKeyUnionReader::Secp256k1(item)
    }
}
impl PublicKeyUnion {
    pub const NAME: &'static str = "PublicKeyUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            PublicKeyUnion::Secp256k1(item) => item.as_bytes(),
            PublicKeyUnion::NotSet => Default::default(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            PublicKeyUnion::Secp256k1(item) => item.as_slice(),
            PublicKeyUnion::NotSet => &[],
        }
    }
    pub fn item_id(&self) -> molecule::ItemId {
        match self {
            PublicKeyUnion::Secp256k1(_) => 1,
            PublicKeyUnion::NotSet => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PublicKeyUnion::Secp256k1(_) => "Secp256k1",
            PublicKeyUnion::NotSet => "NotSet",
        }
    }
    pub fn as_reader<'r>(&'r self) -> PublicKeyUnionReader<'r> {
        match self {
            PublicKeyUnion::Secp256k1(item) => item.as_reader().into(),
            PublicKeyUnion::NotSet => PublicKeyUnionReader::NotSet,
        }
    }
}
impl<'r> PublicKeyUnionReader<'r> {
    pub const NAME: &'r str = "PublicKeyUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            PublicKeyUnionReader::Secp256k1(item) => item.as_slice(),
            PublicKeyUnionReader::NotSet => &[],
        }
    }
    pub fn item_id(&self) -> molecule::ItemId {
        match self {
            PublicKeyUnionReader::Secp256k1(_) => 1,
            PublicKeyUnionReader::NotSet => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PublicKeyUnionReader::Secp256k1(_) => "Secp256k1",
            PublicKeyUnionReader::NotSet => "NotSet",
        }
    }
}
#[derive(Debug, Default)]
pub struct PublicKeyBuilder(pub(crate) PublicKeyUnion);
impl molecule::prelude::Entity for PublicKey {
    type Builder = PublicKeyBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PublicKey(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PublicKeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
impl ::std::default::Default for PublicKey {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        PublicKey::new_unchecked(v.into())
    }
}
impl PublicKey {
    pub const NAME: &'static str = "PublicKey";
    pub fn as_reader<'r>(&'r self) -> PublicKeyReader<'r> {
        PublicKeyReader::new_unchecked(self.as_slice())
    }
    pub const ITEM_COUNT: usize = 1;
    pub fn item_id(&self) -> molecule::ItemId {
        molecule::extract_item_id(self.as_slice())
    }
    pub fn to_enum(&self) -> PublicKeyUnion {
        let inner = self.0.slice_from(molecule::ITEM_ID_SIZE);
        match self.item_id() {
            1 => Secp256k1::new_unchecked(inner).into(),
            0 => PublicKeyUnion::NotSet,
            _ => unreachable!(),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PublicKeyReader<'r> {
    type Entity = PublicKey;
    fn to_entity(&self) -> Self::Entity {
        PublicKey::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PublicKeyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        if slice.len() < molecule::ITEM_ID_SIZE {
            let err = VerificationError::HeaderIsBroken(
                Self::NAME.to_owned(),
                molecule::ITEM_ID_SIZE,
                slice.len(),
            );
            Err(err)?;
        }
        let item_id = molecule::extract_item_id(slice);
        match item_id {
            1 => Secp256k1Reader::verify(&slice[molecule::ITEM_ID_SIZE..]),
            _ => {
                let err = VerificationError::UnknownItem(Self::NAME.to_owned(), 1, item_id);
                Err(err)
            }
        }?;
        Ok(())
    }
}
impl<'r> PublicKeyReader<'r> {
    pub const NAME: &'r str = "PublicKeyReader";
    pub const ITEM_COUNT: usize = 1;
    pub fn item_id(&self) -> molecule::ItemId {
        molecule::extract_item_id(self.as_slice())
    }
    pub fn to_enum(&self) -> PublicKeyUnionReader<'r> {
        let inner = &self.as_slice()[molecule::ITEM_ID_SIZE..];
        match self.item_id() {
            1 => Secp256k1Reader::new_unchecked(inner).into(),
            0 => PublicKeyUnionReader::NotSet,
            _ => unreachable!(),
        }
    }
}
impl molecule::prelude::Builder for PublicKeyBuilder {
    type Entity = PublicKey;
    fn expected_length(&self) -> usize {
        molecule::ITEM_ID_SIZE + self.0.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let item_id = self.0.item_id().to_le_bytes();
        writer.write_all(&item_id[..])?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        PublicKey::new_unchecked(inner.into())
    }
}
impl PublicKeyBuilder {
    pub const NAME: &'static str = "PublicKeyBuilder";
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::std::convert::Into<PublicKeyUnion>,
    {
        self.0 = v.into();
        self
    }
}
#[derive(Clone)]
pub struct Propose(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct ProposeReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Propose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for ProposeReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Propose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "rand", self.rand())?;
        write!(f, ", {}: {}", "pubkey", self.pubkey())?;
        write!(f, ", {}: {}", "exchanges", self.exchanges())?;
        write!(f, ", {}: {}", "ciphers", self.ciphers())?;
        write!(f, ", {}: {}", "hashes", self.hashes())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 5 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for ProposeReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "rand", self.rand())?;
        write!(f, ", {}: {}", "pubkey", self.pubkey())?;
        write!(f, ", {}: {}", "exchanges", self.exchanges())?;
        write!(f, ", {}: {}", "ciphers", self.ciphers())?;
        write!(f, ", {}: {}", "hashes", self.hashes())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 5 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct ProposeBuilder {
    pub(crate) rand: Bytes,
    pub(crate) pubkey: Bytes,
    pub(crate) exchanges: String,
    pub(crate) ciphers: String,
    pub(crate) hashes: String,
}
impl ::std::default::Default for Propose {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            44, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Propose::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for Propose {
    type Builder = ProposeBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Propose(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ProposeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .rand(self.rand())
            .pubkey(self.pubkey())
            .exchanges(self.exchanges())
            .ciphers(self.ciphers())
            .hashes(self.hashes())
    }
}
impl Propose {
    pub const NAME: &'static str = "Propose";
    pub fn as_reader<'r>(&'r self) -> ProposeReader<'r> {
        ProposeReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 5;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn rand(&self) -> Bytes {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        Bytes::new_unchecked(self.0.slice(start, end))
    }
    pub fn pubkey(&self) -> Bytes {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        let end = u32::from_le(offsets[1 + 1]) as usize;
        Bytes::new_unchecked(self.0.slice(start, end))
    }
    pub fn exchanges(&self) -> String {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[2]) as usize;
        let end = u32::from_le(offsets[2 + 1]) as usize;
        String::new_unchecked(self.0.slice(start, end))
    }
    pub fn ciphers(&self) -> String {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[3]) as usize;
        let end = u32::from_le(offsets[3 + 1]) as usize;
        String::new_unchecked(self.0.slice(start, end))
    }
    pub fn hashes(&self) -> String {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[4]) as usize;
        if count == 5 {
            String::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[4 + 1]) as usize;
            String::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ProposeReader<'r> {
    type Entity = Propose;
    fn to_entity(&self) -> Self::Entity {
        Propose::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ProposeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 5 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 5;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let mut offsets: Vec<usize> = ptr[1..=5]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        if offsets[0] != expected {
            let err =
                VerificationError::FirstOffsetIsShort(Self::NAME.to_owned(), expected, offsets[0]);
            Err(err)?;
        }
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]])?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]])?;
        StringReader::verify(&slice[offsets[2]..offsets[3]])?;
        StringReader::verify(&slice[offsets[3]..offsets[4]])?;
        StringReader::verify(&slice[offsets[4]..offsets[5]])?;
        Ok(())
    }
}
impl<'r> ProposeReader<'r> {
    pub const NAME: &'r str = "ProposeReader";
    pub const FIELD_COUNT: usize = 5;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn rand(&self) -> BytesReader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pubkey(&self) -> BytesReader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        let end = u32::from_le(offsets[1 + 1]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn exchanges(&self) -> StringReader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[2]) as usize;
        let end = u32::from_le(offsets[2 + 1]) as usize;
        StringReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn ciphers(&self) -> StringReader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[3]) as usize;
        let end = u32::from_le(offsets[3 + 1]) as usize;
        StringReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn hashes(&self) -> StringReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[4]) as usize;
        if count == 5 {
            StringReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[4 + 1]) as usize;
            StringReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for ProposeBuilder {
    type Entity = Propose;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 5 * 4;
        len_header
            + self.rand.as_slice().len()
            + self.pubkey.as_slice().len()
            + self.exchanges.as_slice().len()
            + self.ciphers.as_slice().len()
            + self.hashes.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 5 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.rand.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.pubkey.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.exchanges.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.ciphers.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.hashes.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.rand.as_slice())?;
        writer.write_all(self.pubkey.as_slice())?;
        writer.write_all(self.exchanges.as_slice())?;
        writer.write_all(self.ciphers.as_slice())?;
        writer.write_all(self.hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Propose::new_unchecked(inner.into())
    }
}
impl ProposeBuilder {
    pub const NAME: &'static str = "ProposeBuilder";
    pub fn rand(mut self, v: Bytes) -> Self {
        self.rand = v;
        self
    }
    pub fn pubkey(mut self, v: Bytes) -> Self {
        self.pubkey = v;
        self
    }
    pub fn exchanges(mut self, v: String) -> Self {
        self.exchanges = v;
        self
    }
    pub fn ciphers(mut self, v: String) -> Self {
        self.ciphers = v;
        self
    }
    pub fn hashes(mut self, v: String) -> Self {
        self.hashes = v;
        self
    }
}
#[derive(Clone)]
pub struct Exchange(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct ExchangeReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Exchange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for ExchangeReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Exchange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "epubkey", self.epubkey())?;
        write!(f, ", {}: {}", "signature", self.signature())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 2 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for ExchangeReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "epubkey", self.epubkey())?;
        write!(f, ", {}: {}", "signature", self.signature())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 2 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct ExchangeBuilder {
    pub(crate) epubkey: Bytes,
    pub(crate) signature: Bytes,
}
impl ::std::default::Default for Exchange {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Exchange::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for Exchange {
    type Builder = ExchangeBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Exchange(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ExchangeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .epubkey(self.epubkey())
            .signature(self.signature())
    }
}
impl Exchange {
    pub const NAME: &'static str = "Exchange";
    pub fn as_reader<'r>(&'r self) -> ExchangeReader<'r> {
        ExchangeReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 2;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn epubkey(&self) -> Bytes {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        Bytes::new_unchecked(self.0.slice(start, end))
    }
    pub fn signature(&self) -> Bytes {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        if count == 2 {
            Bytes::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[1 + 1]) as usize;
            Bytes::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ExchangeReader<'r> {
    type Entity = Exchange;
    fn to_entity(&self) -> Self::Entity {
        Exchange::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ExchangeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 2 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 2;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let mut offsets: Vec<usize> = ptr[1..=2]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        if offsets[0] != expected {
            let err =
                VerificationError::FirstOffsetIsShort(Self::NAME.to_owned(), expected, offsets[0]);
            Err(err)?;
        }
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]])?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]])?;
        Ok(())
    }
}
impl<'r> ExchangeReader<'r> {
    pub const NAME: &'r str = "ExchangeReader";
    pub const FIELD_COUNT: usize = 2;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn epubkey(&self) -> BytesReader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn signature(&self) -> BytesReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        if count == 2 {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[1 + 1]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for ExchangeBuilder {
    type Entity = Exchange;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 2 * 4;
        len_header + self.epubkey.as_slice().len() + self.signature.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 2 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.epubkey.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.signature.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.epubkey.as_slice())?;
        writer.write_all(self.signature.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Exchange::new_unchecked(inner.into())
    }
}
impl ExchangeBuilder {
    pub const NAME: &'static str = "ExchangeBuilder";
    pub fn epubkey(mut self, v: Bytes) -> Self {
        self.epubkey = v;
        self
    }
    pub fn signature(mut self, v: Bytes) -> Self {
        self.signature = v;
        self
    }
}
