// automatically generated by the FlatBuffers compiler, do not modify


pub mod p2p {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
pub mod handshake {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Type {
  Secp256k1 = 0,

}

const ENUM_MIN_TYPE: i8 = 0;
const ENUM_MAX_TYPE: i8 = 0;

impl<'a> flatbuffers::Follow<'a> for Type {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Type {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const Type;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const Type;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Type {
    type Output = Type;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Type>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_TYPE:[Type; 1] = [
  Type::Secp256k1
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_TYPE:[&'static str; 1] = [
    "Secp256k1"
];

pub fn enum_name_type(e: Type) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_TYPE[index]
}

pub enum PublicKeyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct PublicKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PublicKey<'a> {
    type Inner = PublicKey<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> PublicKey<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PublicKey {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PublicKeyArgs<'args>) -> flatbuffers::WIPOffset<PublicKey<'bldr>> {
      let mut builder = PublicKeyBuilder::new(_fbb);
      if let Some(x) = args.pubkey { builder.add_pubkey(x); }
      builder.add_key_type(args.key_type);
      builder.finish()
    }

    pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key_type(&self) -> Type {
    self._tab.get::<Type>(PublicKey::VT_KEY_TYPE, Some(Type::Secp256k1)).unwrap()
  }
  #[inline]
  pub fn pubkey(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PublicKey::VT_PUBKEY, None).map(|v| v.safe_slice())
  }
}

pub struct PublicKeyArgs<'a> {
    pub key_type: Type,
    pub pubkey: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for PublicKeyArgs<'a> {
    #[inline]
    fn default() -> Self {
        PublicKeyArgs {
            key_type: Type::Secp256k1,
            pubkey: None,
        }
    }
}
pub struct PublicKeyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PublicKeyBuilder<'a, 'b> {
  #[inline]
  pub fn add_key_type(&mut self, key_type: Type) {
    self.fbb_.push_slot::<Type>(PublicKey::VT_KEY_TYPE, key_type, Type::Secp256k1);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PublicKey::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PublicKeyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PublicKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PublicKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ProposeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Propose<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Propose<'a> {
    type Inner = Propose<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Propose<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Propose {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ProposeArgs<'args>) -> flatbuffers::WIPOffset<Propose<'bldr>> {
      let mut builder = ProposeBuilder::new(_fbb);
      if let Some(x) = args.hashes { builder.add_hashes(x); }
      if let Some(x) = args.ciphers { builder.add_ciphers(x); }
      if let Some(x) = args.exchanges { builder.add_exchanges(x); }
      if let Some(x) = args.pubkey { builder.add_pubkey(x); }
      if let Some(x) = args.rand { builder.add_rand(x); }
      builder.finish()
    }

    pub const VT_RAND: flatbuffers::VOffsetT = 4;
    pub const VT_PUBKEY: flatbuffers::VOffsetT = 6;
    pub const VT_EXCHANGES: flatbuffers::VOffsetT = 8;
    pub const VT_CIPHERS: flatbuffers::VOffsetT = 10;
    pub const VT_HASHES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn rand(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Propose::VT_RAND, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn pubkey(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Propose::VT_PUBKEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn exchanges(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Propose::VT_EXCHANGES, None)
  }
  #[inline]
  pub fn ciphers(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Propose::VT_CIPHERS, None)
  }
  #[inline]
  pub fn hashes(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Propose::VT_HASHES, None)
  }
}

pub struct ProposeArgs<'a> {
    pub rand: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub pubkey: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub exchanges: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub ciphers: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub hashes: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for ProposeArgs<'a> {
    #[inline]
    fn default() -> Self {
        ProposeArgs {
            rand: None,
            pubkey: None,
            exchanges: None,
            ciphers: None,
            hashes: None,
        }
    }
}
pub struct ProposeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ProposeBuilder<'a, 'b> {
  #[inline]
  pub fn add_rand(&mut self, rand: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Propose::VT_RAND, rand);
  }
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Propose::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_exchanges(&mut self, exchanges: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Propose::VT_EXCHANGES, exchanges);
  }
  #[inline]
  pub fn add_ciphers(&mut self, ciphers: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Propose::VT_CIPHERS, ciphers);
  }
  #[inline]
  pub fn add_hashes(&mut self, hashes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Propose::VT_HASHES, hashes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProposeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ProposeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Propose<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ExchangeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Exchange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Exchange<'a> {
    type Inner = Exchange<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Exchange<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Exchange {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExchangeArgs<'args>) -> flatbuffers::WIPOffset<Exchange<'bldr>> {
      let mut builder = ExchangeBuilder::new(_fbb);
      if let Some(x) = args.signature { builder.add_signature(x); }
      if let Some(x) = args.epubkey { builder.add_epubkey(x); }
      builder.finish()
    }

    pub const VT_EPUBKEY: flatbuffers::VOffsetT = 4;
    pub const VT_SIGNATURE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn epubkey(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Exchange::VT_EPUBKEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn signature(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Exchange::VT_SIGNATURE, None).map(|v| v.safe_slice())
  }
}

pub struct ExchangeArgs<'a> {
    pub epubkey: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for ExchangeArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExchangeArgs {
            epubkey: None,
            signature: None,
        }
    }
}
pub struct ExchangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExchangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_epubkey(&mut self, epubkey: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Exchange::VT_EPUBKEY, epubkey);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Exchange::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExchangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExchangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Exchange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod Handshake
}  // pub mod P2P

