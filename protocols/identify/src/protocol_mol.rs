// Generated by Molecule 0.3.1

use molecule::faster_hex::hex_string;
use molecule::prelude::{Entity as _, Reader as _};
#[derive(Clone)]
pub struct Bytes(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct BytesReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Bytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for BytesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Bytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for BytesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
#[derive(Debug, Default)]
pub struct BytesBuilder(pub(crate) Vec<u8>);
impl molecule::prelude::Entity for Bytes {
    type Builder = BytesBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bytes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for Bytes {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Bytes::new_unchecked(v.into())
    }
}
impl Bytes {
    pub const NAME: &'static str = "Bytes";
    pub fn as_reader<'r>(&'r self) -> BytesReader<'r> {
        BytesReader::new_unchecked(self.as_slice())
    }
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice_from(4)
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesReader<'r> {
    type Entity = Bytes;
    fn to_entity(&self) -> Self::Entity {
        Bytes::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let item_count = u32::from_le(ptr[0]) as usize;
        let expected = 4 + 1 * item_count;
        if len != expected {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), expected, len);
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> BytesReader<'r> {
    pub const NAME: &'r str = "BytesReader";
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[4..]
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl molecule::prelude::Builder for BytesBuilder {
    type Entity = Bytes;
    fn expected_length(&self) -> usize {
        4 + 1 * self.0.len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.0.len() as u32).to_le_bytes();
        writer.write_all(&len)?;
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Bytes::new_unchecked(inner.into())
    }
}
impl BytesBuilder {
    pub const NAME: &'static str = "BytesBuilder";
    pub fn set(mut self, v: Vec<u8>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: u8) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = u8>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct BytesIterator(Bytes, usize, usize);
impl ::std::iter::Iterator for BytesIterator {
    type Item = u8;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for BytesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for Bytes {
    type Item = u8;
    type IntoIter = BytesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct AddressVec(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct AddressVecReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for AddressVec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for AddressVecReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for AddressVec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> ::std::fmt::Display for AddressVecReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
#[derive(Debug, Default)]
pub struct AddressVecBuilder(pub(crate) Vec<Address>);
impl molecule::prelude::Entity for AddressVec {
    type Builder = AddressVecBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        AddressVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddressVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddressVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for AddressVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        AddressVec::new_unchecked(v.into())
    }
}
impl AddressVec {
    pub const NAME: &'static str = "AddressVec";
    pub fn as_reader<'r>(&'r self) -> AddressVecReader<'r> {
        AddressVecReader::new_unchecked(self.as_slice())
    }
    pub fn offsets(&self) -> (usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        (bytes_len, &ptr[1..])
    }
    pub fn len(&self) -> usize {
        let (bytes_len, offsets) = self.offsets();
        if bytes_len == 4 {
            0
        } else {
            let first = u32::from_le(offsets[0]) as usize;
            (first - 4) / 4
        }
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Address> {
        let len = self.len();
        if idx >= len {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Address {
        let len = self.len();
        let (_, offsets) = self.offsets();
        let start = u32::from_le(offsets[idx]) as usize;
        if idx == len - 1 {
            Address::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[idx + 1]) as usize;
            Address::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AddressVecReader<'r> {
    type Entity = AddressVec;
    fn to_entity(&self) -> Self::Entity {
        AddressVec::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AddressVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if total_size == 4 {
            return Ok(());
        }
        if total_size < 4 + 4 {
            let err = VerificationError::DataIsShort(Self::NAME.to_owned(), 8, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < 4 + 4 {
            let err = VerificationError::FirstOffsetIsShort(Self::NAME.to_owned(), 8, offset_first);
            Err(err)?;
        }
        let item_count = offset_first / 4 - 1;
        let expected = 4 + 4 * item_count;
        if total_size < expected {
            let err = VerificationError::DataIsShort(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let mut offsets: Vec<usize> = ptr[1..(item_count + 1)]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        for i in 0..=(offsets.len() - 2) {
            let start = offsets[i];
            let end = offsets[i + 1];
            AddressReader::verify(&slice[start..end], _compatible)?;
        }
        Ok(())
    }
}
impl<'r> AddressVecReader<'r> {
    pub const NAME: &'r str = "AddressVecReader";
    pub fn offsets(&self) -> (usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        (bytes_len, &ptr[1..])
    }
    pub fn len(&self) -> usize {
        let (bytes_len, offsets) = self.offsets();
        if bytes_len == 4 {
            0
        } else {
            let first = u32::from_le(offsets[0]) as usize;
            (first - 4) / 4
        }
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<AddressReader<'r>> {
        let len = self.len();
        if idx >= len {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> AddressReader<'r> {
        let len = self.len();
        let (_, offsets) = self.offsets();
        let start = u32::from_le(offsets[idx]) as usize;
        if idx == len - 1 {
            AddressReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[idx + 1]) as usize;
            AddressReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for AddressVecBuilder {
    type Entity = AddressVec;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 4 * self.0.len();
        len_header
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 4 * self.0.len();
        for inner in &self.0[..] {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += inner.as_slice().len();
        }
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        AddressVec::new_unchecked(inner.into())
    }
}
impl AddressVecBuilder {
    pub const NAME: &'static str = "AddressVecBuilder";
    pub fn set(mut self, v: Vec<Address>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Address) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = Address>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct AddressVecIterator(AddressVec, usize, usize);
impl ::std::iter::Iterator for AddressVecIterator {
    type Item = Address;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for AddressVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for AddressVec {
    type Item = Address;
    type IntoIter = AddressVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        AddressVecIterator(self, 0, len)
    }
}
impl<'r> AddressVecReader<'r> {
    pub fn iter<'t>(&'t self) -> AddressVecReaderIterator<'t, 'r> {
        AddressVecReaderIterator(&self, 0, self.len())
    }
}
pub struct AddressVecReaderIterator<'t, 'r>(&'t AddressVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::std::iter::Iterator for AddressVecReaderIterator<'t, 'r> {
    type Item = AddressReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::std::iter::ExactSizeIterator for AddressVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Address(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct AddressReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for AddressReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "bytes", self.bytes())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for AddressReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "bytes", self.bytes())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct AddressBuilder {
    pub(crate) bytes: Bytes,
}
impl ::std::default::Default for Address {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        Address::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for Address {
    type Builder = AddressBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Address(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddressReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddressReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().bytes(self.bytes())
    }
}
impl Address {
    pub const NAME: &'static str = "Address";
    pub fn as_reader<'r>(&'r self) -> AddressReader<'r> {
        AddressReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn bytes(&self) -> Bytes {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            Bytes::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            Bytes::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AddressReader<'r> {
    type Entity = Address;
    fn to_entity(&self) -> Self::Entity {
        Address::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AddressReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 1 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 1;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < expected {
            let err = VerificationError::FirstOffsetIsShort(
                Self::NAME.to_owned(),
                expected,
                offset_first,
            );
            Err(err)?;
        }
        let real_field_count = if compatible {
            let real_field_count = offset_first / 4 - 1;
            let real_expected = 4 + 4 * real_field_count;
            if total_size < real_expected {
                let err = VerificationError::DataIsShort(
                    Self::NAME.to_owned(),
                    real_expected,
                    total_size,
                );
                Err(err)?;
            }
            real_field_count
        } else {
            if offset_first > expected {
                let err = VerificationError::FirstOffsetIsOverflow(
                    Self::NAME.to_owned(),
                    expected,
                    offset_first,
                );
                Err(err)?;
            }
            1
        };
        let mut offsets: Vec<usize> = ptr[1..=real_field_count]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
impl<'r> AddressReader<'r> {
    pub const NAME: &'r str = "AddressReader";
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn bytes(&self) -> BytesReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for AddressBuilder {
    type Entity = Address;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 1 * 4;
        len_header + self.bytes.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 1 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.bytes.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.bytes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Address::new_unchecked(inner.into())
    }
}
impl AddressBuilder {
    pub const NAME: &'static str = "AddressBuilder";
    pub fn bytes(mut self, v: Bytes) -> Self {
        self.bytes = v;
        self
    }
}
#[derive(Clone)]
pub struct IdentifyMessage(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct IdentifyMessageReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for IdentifyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for IdentifyMessageReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for IdentifyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "listen_addrs", self.listen_addrs())?;
        write!(f, ", {}: {}", "observed_addr", self.observed_addr())?;
        write!(f, ", {}: {}", "identify", self.identify())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 3 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for IdentifyMessageReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "listen_addrs", self.listen_addrs())?;
        write!(f, ", {}: {}", "observed_addr", self.observed_addr())?;
        write!(f, ", {}: {}", "identify", self.identify())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 3 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct IdentifyMessageBuilder {
    pub(crate) listen_addrs: AddressVec,
    pub(crate) observed_addr: Address,
    pub(crate) identify: Bytes,
}
impl ::std::default::Default for IdentifyMessage {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            36, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 32, 0, 0, 0, 4, 0, 0, 0, 12, 0, 0, 0, 8, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        IdentifyMessage::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for IdentifyMessage {
    type Builder = IdentifyMessageBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        IdentifyMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IdentifyMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IdentifyMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .listen_addrs(self.listen_addrs())
            .observed_addr(self.observed_addr())
            .identify(self.identify())
    }
}
impl IdentifyMessage {
    pub const NAME: &'static str = "IdentifyMessage";
    pub fn as_reader<'r>(&'r self) -> IdentifyMessageReader<'r> {
        IdentifyMessageReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 3;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn listen_addrs(&self) -> AddressVec {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        AddressVec::new_unchecked(self.0.slice(start, end))
    }
    pub fn observed_addr(&self) -> Address {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        let end = u32::from_le(offsets[1 + 1]) as usize;
        Address::new_unchecked(self.0.slice(start, end))
    }
    pub fn identify(&self) -> Bytes {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[2]) as usize;
        if count == 3 {
            Bytes::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[2 + 1]) as usize;
            Bytes::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for IdentifyMessageReader<'r> {
    type Entity = IdentifyMessage;
    fn to_entity(&self) -> Self::Entity {
        IdentifyMessage::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        IdentifyMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 3 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 3;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < expected {
            let err = VerificationError::FirstOffsetIsShort(
                Self::NAME.to_owned(),
                expected,
                offset_first,
            );
            Err(err)?;
        }
        let real_field_count = if compatible {
            let real_field_count = offset_first / 4 - 1;
            let real_expected = 4 + 4 * real_field_count;
            if total_size < real_expected {
                let err = VerificationError::DataIsShort(
                    Self::NAME.to_owned(),
                    real_expected,
                    total_size,
                );
                Err(err)?;
            }
            real_field_count
        } else {
            if offset_first > expected {
                let err = VerificationError::FirstOffsetIsOverflow(
                    Self::NAME.to_owned(),
                    expected,
                    offset_first,
                );
                Err(err)?;
            }
            3
        };
        let mut offsets: Vec<usize> = ptr[1..=real_field_count]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        AddressVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        AddressReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
impl<'r> IdentifyMessageReader<'r> {
    pub const NAME: &'r str = "IdentifyMessageReader";
    pub const FIELD_COUNT: usize = 3;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn listen_addrs(&self) -> AddressVecReader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        AddressVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn observed_addr(&self) -> AddressReader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        let end = u32::from_le(offsets[1 + 1]) as usize;
        AddressReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn identify(&self) -> BytesReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[2]) as usize;
        if count == 3 {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[2 + 1]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for IdentifyMessageBuilder {
    type Entity = IdentifyMessage;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 3 * 4;
        len_header
            + self.listen_addrs.as_slice().len()
            + self.observed_addr.as_slice().len()
            + self.identify.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 3 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.listen_addrs.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.observed_addr.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.identify.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.listen_addrs.as_slice())?;
        writer.write_all(self.observed_addr.as_slice())?;
        writer.write_all(self.identify.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        IdentifyMessage::new_unchecked(inner.into())
    }
}
impl IdentifyMessageBuilder {
    pub const NAME: &'static str = "IdentifyMessageBuilder";
    pub fn listen_addrs(mut self, v: AddressVec) -> Self {
        self.listen_addrs = v;
        self
    }
    pub fn observed_addr(mut self, v: Address) -> Self {
        self.observed_addr = v;
        self
    }
    pub fn identify(mut self, v: Bytes) -> Self {
        self.identify = v;
        self
    }
}
