// Generated by Molecule 0.3.1

use molecule::faster_hex::hex_string;
use molecule::prelude::{Entity as _, Reader as _};
#[derive(Clone)]
pub struct Uint32(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct Uint32Reader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Uint32 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for Uint32Reader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Uint32 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for Uint32Reader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
pub struct Uint32Builder(pub(crate) [u8; 4]);
impl ::std::fmt::Debug for Uint32Builder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::std::default::Default for Uint32Builder {
    fn default() -> Self {
        Uint32Builder([0; 4])
    }
}
impl molecule::prelude::Entity for Uint32 {
    type Builder = Uint32Builder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint32(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2(), self.nth3()])
    }
}
impl ::std::default::Default for Uint32 {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Uint32::new_unchecked(v.into())
    }
}
impl Uint32 {
    pub const NAME: &'static str = "Uint32";
    pub fn as_reader<'r>(&'r self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(self.as_slice())
    }
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn nth0(&self) -> u8 {
        self.0[0]
    }
    pub fn nth1(&self) -> u8 {
        self.0[1]
    }
    pub fn nth2(&self) -> u8 {
        self.0[2]
    }
    pub fn nth3(&self) -> u8 {
        self.0[3]
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint32Reader<'r> {
    type Entity = Uint32;
    fn to_entity(&self) -> Self::Entity {
        Uint32::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint32Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        if slice.len() != 4 {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), 4, slice.len());
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> Uint32Reader<'r> {
    pub const NAME: &'r str = "Uint32Reader";
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
    pub fn nth0(&self) -> u8 {
        self.0[0]
    }
    pub fn nth1(&self) -> u8 {
        self.0[1]
    }
    pub fn nth2(&self) -> u8 {
        self.0[2]
    }
    pub fn nth3(&self) -> u8 {
        self.0[3]
    }
}
impl molecule::prelude::Builder for Uint32Builder {
    type Entity = Uint32;
    fn expected_length(&self) -> usize {
        4
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Uint32::new_unchecked(inner.into())
    }
}
impl Uint32Builder {
    pub const NAME: &'static str = "Uint32Builder";
    pub fn set(mut self, v: [u8; 4]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: u8) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: u8) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: u8) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: u8) -> Self {
        self.0[3] = v;
        self
    }
}
#[derive(Clone)]
pub struct PingPayload(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct PingPayloadReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for PingPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for PingPayloadReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for PingPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> ::std::fmt::Display for PingPayloadReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
#[derive(Debug, Clone)]
pub enum PingPayloadUnion {
    NotSet,
    Ping(Ping),
    Pong(Pong),
}
#[derive(Debug, Clone, Copy)]
pub enum PingPayloadUnionReader<'r> {
    NotSet,
    Ping(PingReader<'r>),
    Pong(PongReader<'r>),
}
impl ::std::default::Default for PingPayloadUnion {
    fn default() -> Self {
        PingPayloadUnion::Ping(::std::default::Default::default())
    }
}
impl ::std::fmt::Display for PingPayloadUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            PingPayloadUnion::Ping(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Ping::NAME, item)
            }
            PingPayloadUnion::Pong(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Pong::NAME, item)
            }
            PingPayloadUnion::NotSet => write!(f, "NotSet"),
        }
    }
}
impl<'r> ::std::fmt::Display for PingPayloadUnionReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            PingPayloadUnionReader::Ping(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Ping::NAME, item)
            }
            PingPayloadUnionReader::Pong(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Pong::NAME, item)
            }
            PingPayloadUnionReader::NotSet => write!(f, "NotSet"),
        }
    }
}
impl PingPayloadUnion {
    pub(crate) fn display_inner(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            PingPayloadUnion::Ping(ref item) => write!(f, "{}", item),
            PingPayloadUnion::Pong(ref item) => write!(f, "{}", item),
            PingPayloadUnion::NotSet => write!(f, "NotSet"),
        }
    }
}
impl<'r> PingPayloadUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            PingPayloadUnionReader::Ping(ref item) => write!(f, "{}", item),
            PingPayloadUnionReader::Pong(ref item) => write!(f, "{}", item),
            PingPayloadUnionReader::NotSet => write!(f, "NotSet"),
        }
    }
}
impl ::std::convert::From<Ping> for PingPayloadUnion {
    fn from(item: Ping) -> Self {
        PingPayloadUnion::Ping(item)
    }
}
impl ::std::convert::From<Pong> for PingPayloadUnion {
    fn from(item: Pong) -> Self {
        PingPayloadUnion::Pong(item)
    }
}
impl<'r> ::std::convert::From<PingReader<'r>> for PingPayloadUnionReader<'r> {
    fn from(item: PingReader<'r>) -> Self {
        PingPayloadUnionReader::Ping(item)
    }
}
impl<'r> ::std::convert::From<PongReader<'r>> for PingPayloadUnionReader<'r> {
    fn from(item: PongReader<'r>) -> Self {
        PingPayloadUnionReader::Pong(item)
    }
}
impl PingPayloadUnion {
    pub const NAME: &'static str = "PingPayloadUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            PingPayloadUnion::Ping(item) => item.as_bytes(),
            PingPayloadUnion::Pong(item) => item.as_bytes(),
            PingPayloadUnion::NotSet => Default::default(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            PingPayloadUnion::Ping(item) => item.as_slice(),
            PingPayloadUnion::Pong(item) => item.as_slice(),
            PingPayloadUnion::NotSet => &[],
        }
    }
    pub fn item_id(&self) -> molecule::ItemId {
        match self {
            PingPayloadUnion::Ping(_) => 1,
            PingPayloadUnion::Pong(_) => 2,
            PingPayloadUnion::NotSet => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PingPayloadUnion::Ping(_) => "Ping",
            PingPayloadUnion::Pong(_) => "Pong",
            PingPayloadUnion::NotSet => "NotSet",
        }
    }
    pub fn as_reader<'r>(&'r self) -> PingPayloadUnionReader<'r> {
        match self {
            PingPayloadUnion::Ping(item) => item.as_reader().into(),
            PingPayloadUnion::Pong(item) => item.as_reader().into(),
            PingPayloadUnion::NotSet => PingPayloadUnionReader::NotSet,
        }
    }
}
impl<'r> PingPayloadUnionReader<'r> {
    pub const NAME: &'r str = "PingPayloadUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            PingPayloadUnionReader::Ping(item) => item.as_slice(),
            PingPayloadUnionReader::Pong(item) => item.as_slice(),
            PingPayloadUnionReader::NotSet => &[],
        }
    }
    pub fn item_id(&self) -> molecule::ItemId {
        match self {
            PingPayloadUnionReader::Ping(_) => 1,
            PingPayloadUnionReader::Pong(_) => 2,
            PingPayloadUnionReader::NotSet => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            PingPayloadUnionReader::Ping(_) => "Ping",
            PingPayloadUnionReader::Pong(_) => "Pong",
            PingPayloadUnionReader::NotSet => "NotSet",
        }
    }
}
#[derive(Debug, Default)]
pub struct PingPayloadBuilder(pub(crate) PingPayloadUnion);
impl molecule::prelude::Entity for PingPayload {
    type Builder = PingPayloadBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PingPayload(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PingPayloadReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PingPayloadReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
impl ::std::default::Default for PingPayload {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        PingPayload::new_unchecked(v.into())
    }
}
impl PingPayload {
    pub const NAME: &'static str = "PingPayload";
    pub fn as_reader<'r>(&'r self) -> PingPayloadReader<'r> {
        PingPayloadReader::new_unchecked(self.as_slice())
    }
    pub const ITEM_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::ItemId {
        molecule::extract_item_id(self.as_slice())
    }
    pub fn to_enum(&self) -> PingPayloadUnion {
        let inner = self.0.slice_from(molecule::ITEM_ID_SIZE);
        match self.item_id() {
            1 => Ping::new_unchecked(inner).into(),
            2 => Pong::new_unchecked(inner).into(),
            0 => PingPayloadUnion::NotSet,
            _ => unreachable!(),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PingPayloadReader<'r> {
    type Entity = PingPayload;
    fn to_entity(&self) -> Self::Entity {
        PingPayload::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PingPayloadReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        if slice.len() < molecule::ITEM_ID_SIZE {
            let err = VerificationError::HeaderIsBroken(
                Self::NAME.to_owned(),
                molecule::ITEM_ID_SIZE,
                slice.len(),
            );
            Err(err)?;
        }
        let item_id = molecule::extract_item_id(slice);
        match item_id {
            1 => PingReader::verify(&slice[molecule::ITEM_ID_SIZE..], _compatible),
            2 => PongReader::verify(&slice[molecule::ITEM_ID_SIZE..], _compatible),
            _ => {
                let err = VerificationError::UnknownItem(Self::NAME.to_owned(), 2, item_id);
                Err(err)
            }
        }?;
        Ok(())
    }
}
impl<'r> PingPayloadReader<'r> {
    pub const NAME: &'r str = "PingPayloadReader";
    pub const ITEM_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::ItemId {
        molecule::extract_item_id(self.as_slice())
    }
    pub fn to_enum(&self) -> PingPayloadUnionReader<'r> {
        let inner = &self.as_slice()[molecule::ITEM_ID_SIZE..];
        match self.item_id() {
            1 => PingReader::new_unchecked(inner).into(),
            2 => PongReader::new_unchecked(inner).into(),
            0 => PingPayloadUnionReader::NotSet,
            _ => unreachable!(),
        }
    }
}
impl molecule::prelude::Builder for PingPayloadBuilder {
    type Entity = PingPayload;
    fn expected_length(&self) -> usize {
        molecule::ITEM_ID_SIZE + self.0.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let item_id = self.0.item_id().to_le_bytes();
        writer.write_all(&item_id[..])?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        PingPayload::new_unchecked(inner.into())
    }
}
impl PingPayloadBuilder {
    pub const NAME: &'static str = "PingPayloadBuilder";
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::std::convert::Into<PingPayloadUnion>,
    {
        self.0 = v.into();
        self
    }
}
#[derive(Clone)]
pub struct PingMessage(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct PingMessageReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for PingMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for PingMessageReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for PingMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "payload", self.payload())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for PingMessageReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "payload", self.payload())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct PingMessageBuilder {
    pub(crate) payload: PingPayload,
}
impl ::std::default::Default for PingMessage {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        PingMessage::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for PingMessage {
    type Builder = PingMessageBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PingMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PingMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PingMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().payload(self.payload())
    }
}
impl PingMessage {
    pub const NAME: &'static str = "PingMessage";
    pub fn as_reader<'r>(&'r self) -> PingMessageReader<'r> {
        PingMessageReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn payload(&self) -> PingPayload {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            PingPayload::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            PingPayload::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PingMessageReader<'r> {
    type Entity = PingMessage;
    fn to_entity(&self) -> Self::Entity {
        PingMessage::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PingMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 1 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 1;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < expected {
            let err = VerificationError::FirstOffsetIsShort(
                Self::NAME.to_owned(),
                expected,
                offset_first,
            );
            Err(err)?;
        }
        let real_field_count = if compatible {
            let real_field_count = offset_first / 4 - 1;
            let real_expected = 4 + 4 * real_field_count;
            if total_size < real_expected {
                let err = VerificationError::DataIsShort(
                    Self::NAME.to_owned(),
                    real_expected,
                    total_size,
                );
                Err(err)?;
            }
            real_field_count
        } else {
            if offset_first > expected {
                let err = VerificationError::FirstOffsetIsOverflow(
                    Self::NAME.to_owned(),
                    expected,
                    offset_first,
                );
                Err(err)?;
            }
            1
        };
        let mut offsets: Vec<usize> = ptr[1..=real_field_count]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        PingPayloadReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
impl<'r> PingMessageReader<'r> {
    pub const NAME: &'r str = "PingMessageReader";
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn payload(&self) -> PingPayloadReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            PingPayloadReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            PingPayloadReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for PingMessageBuilder {
    type Entity = PingMessage;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 1 * 4;
        len_header + self.payload.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 1 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.payload.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.payload.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        PingMessage::new_unchecked(inner.into())
    }
}
impl PingMessageBuilder {
    pub const NAME: &'static str = "PingMessageBuilder";
    pub fn payload(mut self, v: PingPayload) -> Self {
        self.payload = v;
        self
    }
}
#[derive(Clone)]
pub struct Ping(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct PingReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for PingReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "nonce", self.nonce())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for PingReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "nonce", self.nonce())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct PingBuilder {
    pub(crate) nonce: Uint32,
}
impl ::std::default::Default for Ping {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        Ping::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for Ping {
    type Builder = PingBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Ping(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PingReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PingReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().nonce(self.nonce())
    }
}
impl Ping {
    pub const NAME: &'static str = "Ping";
    pub fn as_reader<'r>(&'r self) -> PingReader<'r> {
        PingReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn nonce(&self) -> Uint32 {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            Uint32::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            Uint32::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PingReader<'r> {
    type Entity = Ping;
    fn to_entity(&self) -> Self::Entity {
        Ping::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PingReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 1 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 1;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < expected {
            let err = VerificationError::FirstOffsetIsShort(
                Self::NAME.to_owned(),
                expected,
                offset_first,
            );
            Err(err)?;
        }
        let real_field_count = if compatible {
            let real_field_count = offset_first / 4 - 1;
            let real_expected = 4 + 4 * real_field_count;
            if total_size < real_expected {
                let err = VerificationError::DataIsShort(
                    Self::NAME.to_owned(),
                    real_expected,
                    total_size,
                );
                Err(err)?;
            }
            real_field_count
        } else {
            if offset_first > expected {
                let err = VerificationError::FirstOffsetIsOverflow(
                    Self::NAME.to_owned(),
                    expected,
                    offset_first,
                );
                Err(err)?;
            }
            1
        };
        let mut offsets: Vec<usize> = ptr[1..=real_field_count]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
impl<'r> PingReader<'r> {
    pub const NAME: &'r str = "PingReader";
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn nonce(&self) -> Uint32Reader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for PingBuilder {
    type Entity = Ping;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 1 * 4;
        len_header + self.nonce.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 1 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.nonce.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.nonce.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Ping::new_unchecked(inner.into())
    }
}
impl PingBuilder {
    pub const NAME: &'static str = "PingBuilder";
    pub fn nonce(mut self, v: Uint32) -> Self {
        self.nonce = v;
        self
    }
}
#[derive(Clone)]
pub struct Pong(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct PongReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Pong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for PongReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Pong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "nonce", self.nonce())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for PongReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "nonce", self.nonce())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct PongBuilder {
    pub(crate) nonce: Uint32,
}
impl ::std::default::Default for Pong {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        Pong::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for Pong {
    type Builder = PongBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Pong(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PongReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PongReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().nonce(self.nonce())
    }
}
impl Pong {
    pub const NAME: &'static str = "Pong";
    pub fn as_reader<'r>(&'r self) -> PongReader<'r> {
        PongReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn nonce(&self) -> Uint32 {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            Uint32::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            Uint32::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PongReader<'r> {
    type Entity = Pong;
    fn to_entity(&self) -> Self::Entity {
        Pong::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PongReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 1 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 1;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < expected {
            let err = VerificationError::FirstOffsetIsShort(
                Self::NAME.to_owned(),
                expected,
                offset_first,
            );
            Err(err)?;
        }
        let real_field_count = if compatible {
            let real_field_count = offset_first / 4 - 1;
            let real_expected = 4 + 4 * real_field_count;
            if total_size < real_expected {
                let err = VerificationError::DataIsShort(
                    Self::NAME.to_owned(),
                    real_expected,
                    total_size,
                );
                Err(err)?;
            }
            real_field_count
        } else {
            if offset_first > expected {
                let err = VerificationError::FirstOffsetIsOverflow(
                    Self::NAME.to_owned(),
                    expected,
                    offset_first,
                );
                Err(err)?;
            }
            1
        };
        let mut offsets: Vec<usize> = ptr[1..=real_field_count]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
impl<'r> PongReader<'r> {
    pub const NAME: &'r str = "PongReader";
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn nonce(&self) -> Uint32Reader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            Uint32Reader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            Uint32Reader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for PongBuilder {
    type Entity = Pong;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 1 * 4;
        len_header + self.nonce.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 1 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.nonce.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.nonce.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Pong::new_unchecked(inner.into())
    }
}
impl PongBuilder {
    pub const NAME: &'static str = "PongBuilder";
    pub fn nonce(mut self, v: Uint32) -> Self {
        self.nonce = v;
        self
    }
}
