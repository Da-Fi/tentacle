//! This file is auto-generated by cfbc.
use super::protocol_generated as reader;

pub mod p2p {
    #![allow(unused_imports)]

    use super::reader::p2p as reader;
    use flatbuffers::{self, Follow};
    use flatbuffers_verifier::{
        try_follow_uoffset, Error, Result, StringVerifier, VectorVerifier, Verify,
        MAX_OFFSET_LOC,
    };
    pub mod discovery {
        #![allow(unused_imports)]

        use super::reader::discovery as reader;
        use flatbuffers::{self, Follow};
        use flatbuffers_verifier::{
            try_follow_uoffset, Error, Result, StringVerifier, VectorVerifier, Verify,
            MAX_OFFSET_LOC,
        };

        impl<'a> Verify for reader::Bytes<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_SEQ as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_SEQ) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let seq_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        seq_verifier.verify_scalar_elements(1)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::DiscoveryMessage<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PAYLOAD_TYPE as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PAYLOAD_TYPE) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 1 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PAYLOAD as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PAYLOAD) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        match self.payload_type() {
                            reader::DiscoveryPayload::GetNodes => self
                                .payload_as_get_nodes()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::DiscoveryPayload::Nodes => self
                                .payload_as_nodes()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::DiscoveryPayload::NONE => return Err(Error::UnmatchedUnion),
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::GetNodes<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_VERSION as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_VERSION) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_COUNT as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_COUNT) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_LISTEN_PORT as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_LISTEN_PORT) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 2 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Node<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_ADDRESSES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_ADDRESSES) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let addresses_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        addresses_verifier
                            .verify_reference_elements::<reader::Bytes>()?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Nodes<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_ANNOUNCE as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_ANNOUNCE) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 1 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_ITEMS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_ITEMS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let items_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        items_verifier
                            .verify_reference_elements::<reader::Node>()?;
                    }
                }

                Ok(())
            }
        }
    }

}
