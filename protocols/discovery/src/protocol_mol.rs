// Generated by Molecule 0.3.1

use molecule::faster_hex::hex_string;
use molecule::prelude::{Entity as _, Reader as _};
#[derive(Clone)]
pub struct Bytes(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct BytesReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Bytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for BytesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Bytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for BytesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
#[derive(Debug, Default)]
pub struct BytesBuilder(pub(crate) Vec<u8>);
impl molecule::prelude::Entity for Bytes {
    type Builder = BytesBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bytes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for Bytes {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Bytes::new_unchecked(v.into())
    }
}
impl Bytes {
    pub const NAME: &'static str = "Bytes";
    pub fn as_reader<'r>(&'r self) -> BytesReader<'r> {
        BytesReader::new_unchecked(self.as_slice())
    }
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice_from(4)
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesReader<'r> {
    type Entity = Bytes;
    fn to_entity(&self) -> Self::Entity {
        Bytes::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let item_count = u32::from_le(ptr[0]) as usize;
        let expected = 4 + 1 * item_count;
        if len != expected {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), expected, len);
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> BytesReader<'r> {
    pub const NAME: &'r str = "BytesReader";
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[4..]
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl molecule::prelude::Builder for BytesBuilder {
    type Entity = Bytes;
    fn expected_length(&self) -> usize {
        4 + 1 * self.0.len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.0.len() as u32).to_le_bytes();
        writer.write_all(&len)?;
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Bytes::new_unchecked(inner.into())
    }
}
impl BytesBuilder {
    pub const NAME: &'static str = "BytesBuilder";
    pub fn set(mut self, v: Vec<u8>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: u8) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = u8>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct BytesIterator(Bytes, usize, usize);
impl ::std::iter::Iterator for BytesIterator {
    type Item = u8;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for BytesIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for Bytes {
    type Item = u8;
    type IntoIter = BytesIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct BytesVec(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct BytesVecReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for BytesVec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for BytesVecReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for BytesVec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> ::std::fmt::Display for BytesVecReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
#[derive(Debug, Default)]
pub struct BytesVecBuilder(pub(crate) Vec<Bytes>);
impl molecule::prelude::Entity for BytesVec {
    type Builder = BytesVecBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BytesVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BytesVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for BytesVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        BytesVec::new_unchecked(v.into())
    }
}
impl BytesVec {
    pub const NAME: &'static str = "BytesVec";
    pub fn as_reader<'r>(&'r self) -> BytesVecReader<'r> {
        BytesVecReader::new_unchecked(self.as_slice())
    }
    pub fn offsets(&self) -> (usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        (bytes_len, &ptr[1..])
    }
    pub fn len(&self) -> usize {
        let (bytes_len, offsets) = self.offsets();
        if bytes_len == 4 {
            0
        } else {
            let first = u32::from_le(offsets[0]) as usize;
            (first - 4) / 4
        }
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Bytes> {
        let len = self.len();
        if idx >= len {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Bytes {
        let len = self.len();
        let (_, offsets) = self.offsets();
        let start = u32::from_le(offsets[idx]) as usize;
        if idx == len - 1 {
            Bytes::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[idx + 1]) as usize;
            Bytes::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BytesVecReader<'r> {
    type Entity = BytesVec;
    fn to_entity(&self) -> Self::Entity {
        BytesVec::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BytesVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if total_size == 4 {
            return Ok(());
        }
        if total_size < 4 + 4 {
            let err = VerificationError::DataIsShort(Self::NAME.to_owned(), 8, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < 4 + 4 {
            let err = VerificationError::FirstOffsetIsShort(Self::NAME.to_owned(), 8, offset_first);
            Err(err)?;
        }
        let item_count = offset_first / 4 - 1;
        let expected = 4 + 4 * item_count;
        if total_size < expected {
            let err = VerificationError::DataIsShort(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let mut offsets: Vec<usize> = ptr[1..(item_count + 1)]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        for i in 0..=(offsets.len() - 2) {
            let start = offsets[i];
            let end = offsets[i + 1];
            BytesReader::verify(&slice[start..end], _compatible)?;
        }
        Ok(())
    }
}
impl<'r> BytesVecReader<'r> {
    pub const NAME: &'r str = "BytesVecReader";
    pub fn offsets(&self) -> (usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        (bytes_len, &ptr[1..])
    }
    pub fn len(&self) -> usize {
        let (bytes_len, offsets) = self.offsets();
        if bytes_len == 4 {
            0
        } else {
            let first = u32::from_le(offsets[0]) as usize;
            (first - 4) / 4
        }
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<BytesReader<'r>> {
        let len = self.len();
        if idx >= len {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> BytesReader<'r> {
        let len = self.len();
        let (_, offsets) = self.offsets();
        let start = u32::from_le(offsets[idx]) as usize;
        if idx == len - 1 {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[idx + 1]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for BytesVecBuilder {
    type Entity = BytesVec;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 4 * self.0.len();
        len_header
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 4 * self.0.len();
        for inner in &self.0[..] {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += inner.as_slice().len();
        }
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        BytesVec::new_unchecked(inner.into())
    }
}
impl BytesVecBuilder {
    pub const NAME: &'static str = "BytesVecBuilder";
    pub fn set(mut self, v: Vec<Bytes>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Bytes) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = Bytes>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct BytesVecIterator(BytesVec, usize, usize);
impl ::std::iter::Iterator for BytesVecIterator {
    type Item = Bytes;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for BytesVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for BytesVec {
    type Item = Bytes;
    type IntoIter = BytesVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        BytesVecIterator(self, 0, len)
    }
}
impl<'r> BytesVecReader<'r> {
    pub fn iter<'t>(&'t self) -> BytesVecReaderIterator<'t, 'r> {
        BytesVecReaderIterator(&self, 0, self.len())
    }
}
pub struct BytesVecReaderIterator<'t, 'r>(&'t BytesVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::std::iter::Iterator for BytesVecReaderIterator<'t, 'r> {
    type Item = BytesReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::std::iter::ExactSizeIterator for BytesVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct NodeVec(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct NodeVecReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for NodeVec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for NodeVecReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for NodeVec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> ::std::fmt::Display for NodeVecReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
#[derive(Debug, Default)]
pub struct NodeVecBuilder(pub(crate) Vec<Node>);
impl molecule::prelude::Entity for NodeVec {
    type Builder = NodeVecBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NodeVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for NodeVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        NodeVec::new_unchecked(v.into())
    }
}
impl NodeVec {
    pub const NAME: &'static str = "NodeVec";
    pub fn as_reader<'r>(&'r self) -> NodeVecReader<'r> {
        NodeVecReader::new_unchecked(self.as_slice())
    }
    pub fn offsets(&self) -> (usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        (bytes_len, &ptr[1..])
    }
    pub fn len(&self) -> usize {
        let (bytes_len, offsets) = self.offsets();
        if bytes_len == 4 {
            0
        } else {
            let first = u32::from_le(offsets[0]) as usize;
            (first - 4) / 4
        }
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Node> {
        let len = self.len();
        if idx >= len {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Node {
        let len = self.len();
        let (_, offsets) = self.offsets();
        let start = u32::from_le(offsets[idx]) as usize;
        if idx == len - 1 {
            Node::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[idx + 1]) as usize;
            Node::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for NodeVecReader<'r> {
    type Entity = NodeVec;
    fn to_entity(&self) -> Self::Entity {
        NodeVec::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NodeVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if total_size == 4 {
            return Ok(());
        }
        if total_size < 4 + 4 {
            let err = VerificationError::DataIsShort(Self::NAME.to_owned(), 8, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < 4 + 4 {
            let err = VerificationError::FirstOffsetIsShort(Self::NAME.to_owned(), 8, offset_first);
            Err(err)?;
        }
        let item_count = offset_first / 4 - 1;
        let expected = 4 + 4 * item_count;
        if total_size < expected {
            let err = VerificationError::DataIsShort(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let mut offsets: Vec<usize> = ptr[1..(item_count + 1)]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        for i in 0..=(offsets.len() - 2) {
            let start = offsets[i];
            let end = offsets[i + 1];
            NodeReader::verify(&slice[start..end], _compatible)?;
        }
        Ok(())
    }
}
impl<'r> NodeVecReader<'r> {
    pub const NAME: &'r str = "NodeVecReader";
    pub fn offsets(&self) -> (usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        (bytes_len, &ptr[1..])
    }
    pub fn len(&self) -> usize {
        let (bytes_len, offsets) = self.offsets();
        if bytes_len == 4 {
            0
        } else {
            let first = u32::from_le(offsets[0]) as usize;
            (first - 4) / 4
        }
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<NodeReader<'r>> {
        let len = self.len();
        if idx >= len {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> NodeReader<'r> {
        let len = self.len();
        let (_, offsets) = self.offsets();
        let start = u32::from_le(offsets[idx]) as usize;
        if idx == len - 1 {
            NodeReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[idx + 1]) as usize;
            NodeReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for NodeVecBuilder {
    type Entity = NodeVec;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 4 * self.0.len();
        len_header
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 4 * self.0.len();
        for inner in &self.0[..] {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += inner.as_slice().len();
        }
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        NodeVec::new_unchecked(inner.into())
    }
}
impl NodeVecBuilder {
    pub const NAME: &'static str = "NodeVecBuilder";
    pub fn set(mut self, v: Vec<Node>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Node) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = Node>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct NodeVecIterator(NodeVec, usize, usize);
impl ::std::iter::Iterator for NodeVecIterator {
    type Item = Node;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for NodeVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for NodeVec {
    type Item = Node;
    type IntoIter = NodeVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        NodeVecIterator(self, 0, len)
    }
}
impl<'r> NodeVecReader<'r> {
    pub fn iter<'t>(&'t self) -> NodeVecReaderIterator<'t, 'r> {
        NodeVecReaderIterator(&self, 0, self.len())
    }
}
pub struct NodeVecReaderIterator<'t, 'r>(&'t NodeVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::std::iter::Iterator for NodeVecReaderIterator<'t, 'r> {
    type Item = NodeReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::std::iter::ExactSizeIterator for NodeVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Uint32(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct Uint32Reader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Uint32 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for Uint32Reader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Uint32 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for Uint32Reader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
pub struct Uint32Builder(pub(crate) [u8; 4]);
impl ::std::fmt::Debug for Uint32Builder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::std::default::Default for Uint32Builder {
    fn default() -> Self {
        Uint32Builder([0; 4])
    }
}
impl molecule::prelude::Entity for Uint32 {
    type Builder = Uint32Builder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint32(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2(), self.nth3()])
    }
}
impl ::std::default::Default for Uint32 {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Uint32::new_unchecked(v.into())
    }
}
impl Uint32 {
    pub const NAME: &'static str = "Uint32";
    pub fn as_reader<'r>(&'r self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(self.as_slice())
    }
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn nth0(&self) -> u8 {
        self.0[0]
    }
    pub fn nth1(&self) -> u8 {
        self.0[1]
    }
    pub fn nth2(&self) -> u8 {
        self.0[2]
    }
    pub fn nth3(&self) -> u8 {
        self.0[3]
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint32Reader<'r> {
    type Entity = Uint32;
    fn to_entity(&self) -> Self::Entity {
        Uint32::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint32Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        if slice.len() != 4 {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), 4, slice.len());
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> Uint32Reader<'r> {
    pub const NAME: &'r str = "Uint32Reader";
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
    pub fn nth0(&self) -> u8 {
        self.0[0]
    }
    pub fn nth1(&self) -> u8 {
        self.0[1]
    }
    pub fn nth2(&self) -> u8 {
        self.0[2]
    }
    pub fn nth3(&self) -> u8 {
        self.0[3]
    }
}
impl molecule::prelude::Builder for Uint32Builder {
    type Entity = Uint32;
    fn expected_length(&self) -> usize {
        4
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Uint32::new_unchecked(inner.into())
    }
}
impl Uint32Builder {
    pub const NAME: &'static str = "Uint32Builder";
    pub fn set(mut self, v: [u8; 4]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: u8) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: u8) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: u8) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: u8) -> Self {
        self.0[3] = v;
        self
    }
}
#[derive(Clone)]
pub struct Uint16(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct Uint16Reader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Uint16 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for Uint16Reader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Uint16 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for Uint16Reader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
pub struct Uint16Builder(pub(crate) [u8; 2]);
impl ::std::fmt::Debug for Uint16Builder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::std::default::Default for Uint16Builder {
    fn default() -> Self {
        Uint16Builder([0; 2])
    }
}
impl molecule::prelude::Entity for Uint16 {
    type Builder = Uint16Builder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint16(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint16Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint16Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
impl ::std::default::Default for Uint16 {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0];
        Uint16::new_unchecked(v.into())
    }
}
impl Uint16 {
    pub const NAME: &'static str = "Uint16";
    pub fn as_reader<'r>(&'r self) -> Uint16Reader<'r> {
        Uint16Reader::new_unchecked(self.as_slice())
    }
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn nth0(&self) -> u8 {
        self.0[0]
    }
    pub fn nth1(&self) -> u8 {
        self.0[1]
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint16Reader<'r> {
    type Entity = Uint16;
    fn to_entity(&self) -> Self::Entity {
        Uint16::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint16Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        if slice.len() != 2 {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), 2, slice.len());
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> Uint16Reader<'r> {
    pub const NAME: &'r str = "Uint16Reader";
    pub const TOTAL_SIZE: usize = 2;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 2;
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
    pub fn nth0(&self) -> u8 {
        self.0[0]
    }
    pub fn nth1(&self) -> u8 {
        self.0[1]
    }
}
impl molecule::prelude::Builder for Uint16Builder {
    type Entity = Uint16;
    fn expected_length(&self) -> usize {
        2
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Uint16::new_unchecked(inner.into())
    }
}
impl Uint16Builder {
    pub const NAME: &'static str = "Uint16Builder";
    pub fn set(mut self, v: [u8; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: u8) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: u8) -> Self {
        self.0[1] = v;
        self
    }
}
#[derive(Clone)]
pub struct Bool(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct BoolReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Bool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for BoolReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Bool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for BoolReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
pub struct BoolBuilder(pub(crate) [u8; 1]);
impl ::std::fmt::Debug for BoolBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::std::default::Default for BoolBuilder {
    fn default() -> Self {
        BoolBuilder([0; 1])
    }
}
impl molecule::prelude::Entity for Bool {
    type Builder = BoolBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
impl ::std::default::Default for Bool {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        Bool::new_unchecked(v.into())
    }
}
impl Bool {
    pub const NAME: &'static str = "Bool";
    pub fn as_reader<'r>(&'r self) -> BoolReader<'r> {
        BoolReader::new_unchecked(self.as_slice())
    }
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn nth0(&self) -> u8 {
        self.0[0]
    }
}
impl<'r> molecule::prelude::Reader<'r> for BoolReader<'r> {
    type Entity = Bool;
    fn to_entity(&self) -> Self::Entity {
        Bool::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        if slice.len() != 1 {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), 1, slice.len());
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> BoolReader<'r> {
    pub const NAME: &'r str = "BoolReader";
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
    pub fn nth0(&self) -> u8 {
        self.0[0]
    }
}
impl molecule::prelude::Builder for BoolBuilder {
    type Entity = Bool;
    fn expected_length(&self) -> usize {
        1
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Bool::new_unchecked(inner.into())
    }
}
impl BoolBuilder {
    pub const NAME: &'static str = "BoolBuilder";
    pub fn set(mut self, v: [u8; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: u8) -> Self {
        self.0[0] = v;
        self
    }
}
#[derive(Clone)]
pub struct PortOpt(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct PortOptReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for PortOpt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for PortOptReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for PortOpt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        {
            if let Some(v) = self.to_opt() {
                write!(f, "{}(Some({}))", Self::NAME, v)
            } else {
                write!(f, "{}(None)", Self::NAME)
            }
        }
    }
}
impl<'r> ::std::fmt::Display for PortOptReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        {
            if let Some(v) = self.to_opt() {
                write!(f, "{}(Some({}))", Self::NAME, v)
            } else {
                write!(f, "{}(None)", Self::NAME)
            }
        }
    }
}
#[derive(Debug, Default)]
pub struct PortOptBuilder(pub(crate) Option<Uint16>);
impl molecule::prelude::Entity for PortOpt {
    type Builder = PortOptBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PortOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PortOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PortOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
impl ::std::default::Default for PortOpt {
    fn default() -> Self {
        let v: Vec<u8> = vec![];
        PortOpt::new_unchecked(v.into())
    }
}
impl PortOpt {
    pub const NAME: &'static str = "PortOpt";
    pub fn as_reader<'r>(&'r self) -> PortOptReader<'r> {
        PortOptReader::new_unchecked(self.as_slice())
    }
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint16> {
        if self.is_none() {
            None
        } else {
            Some(Uint16::new_unchecked(self.0.clone()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for PortOptReader<'r> {
    type Entity = PortOpt;
    fn to_entity(&self) -> Self::Entity {
        PortOpt::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PortOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Uint16Reader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
impl<'r> PortOptReader<'r> {
    pub const NAME: &'r str = "PortOptReader";
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint16Reader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Uint16Reader::new_unchecked(self.as_slice()))
        }
    }
}
impl molecule::prelude::Builder for PortOptBuilder {
    type Entity = PortOpt;
    fn expected_length(&self) -> usize {
        if let Some(ref inner) = self.0 {
            inner.as_slice().len()
        } else {
            0
        }
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        if let Some(ref inner) = self.0 {
            writer.write_all(inner.as_slice())
        } else {
            Ok(())
        }
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        PortOpt::new_unchecked(inner.into())
    }
}
impl PortOptBuilder {
    pub const NAME: &'static str = "PortOptBuilder";
    pub fn set(mut self, v: Option<Uint16>) -> Self {
        self.0 = v;
        self
    }
}
#[derive(Clone)]
pub struct DiscoveryPayload(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct DiscoveryPayloadReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for DiscoveryPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for DiscoveryPayloadReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for DiscoveryPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> ::std::fmt::Display for DiscoveryPayloadReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
#[derive(Debug, Clone)]
pub enum DiscoveryPayloadUnion {
    NotSet,
    GetNodes(GetNodes),
    Nodes(Nodes),
}
#[derive(Debug, Clone, Copy)]
pub enum DiscoveryPayloadUnionReader<'r> {
    NotSet,
    GetNodes(GetNodesReader<'r>),
    Nodes(NodesReader<'r>),
}
impl ::std::default::Default for DiscoveryPayloadUnion {
    fn default() -> Self {
        DiscoveryPayloadUnion::GetNodes(::std::default::Default::default())
    }
}
impl ::std::fmt::Display for DiscoveryPayloadUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            DiscoveryPayloadUnion::GetNodes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetNodes::NAME, item)
            }
            DiscoveryPayloadUnion::Nodes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Nodes::NAME, item)
            }
            DiscoveryPayloadUnion::NotSet => write!(f, "NotSet"),
        }
    }
}
impl<'r> ::std::fmt::Display for DiscoveryPayloadUnionReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            DiscoveryPayloadUnionReader::GetNodes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetNodes::NAME, item)
            }
            DiscoveryPayloadUnionReader::Nodes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Nodes::NAME, item)
            }
            DiscoveryPayloadUnionReader::NotSet => write!(f, "NotSet"),
        }
    }
}
impl DiscoveryPayloadUnion {
    pub(crate) fn display_inner(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            DiscoveryPayloadUnion::GetNodes(ref item) => write!(f, "{}", item),
            DiscoveryPayloadUnion::Nodes(ref item) => write!(f, "{}", item),
            DiscoveryPayloadUnion::NotSet => write!(f, "NotSet"),
        }
    }
}
impl<'r> DiscoveryPayloadUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            DiscoveryPayloadUnionReader::GetNodes(ref item) => write!(f, "{}", item),
            DiscoveryPayloadUnionReader::Nodes(ref item) => write!(f, "{}", item),
            DiscoveryPayloadUnionReader::NotSet => write!(f, "NotSet"),
        }
    }
}
impl ::std::convert::From<GetNodes> for DiscoveryPayloadUnion {
    fn from(item: GetNodes) -> Self {
        DiscoveryPayloadUnion::GetNodes(item)
    }
}
impl ::std::convert::From<Nodes> for DiscoveryPayloadUnion {
    fn from(item: Nodes) -> Self {
        DiscoveryPayloadUnion::Nodes(item)
    }
}
impl<'r> ::std::convert::From<GetNodesReader<'r>> for DiscoveryPayloadUnionReader<'r> {
    fn from(item: GetNodesReader<'r>) -> Self {
        DiscoveryPayloadUnionReader::GetNodes(item)
    }
}
impl<'r> ::std::convert::From<NodesReader<'r>> for DiscoveryPayloadUnionReader<'r> {
    fn from(item: NodesReader<'r>) -> Self {
        DiscoveryPayloadUnionReader::Nodes(item)
    }
}
impl DiscoveryPayloadUnion {
    pub const NAME: &'static str = "DiscoveryPayloadUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            DiscoveryPayloadUnion::GetNodes(item) => item.as_bytes(),
            DiscoveryPayloadUnion::Nodes(item) => item.as_bytes(),
            DiscoveryPayloadUnion::NotSet => Default::default(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            DiscoveryPayloadUnion::GetNodes(item) => item.as_slice(),
            DiscoveryPayloadUnion::Nodes(item) => item.as_slice(),
            DiscoveryPayloadUnion::NotSet => &[],
        }
    }
    pub fn item_id(&self) -> molecule::ItemId {
        match self {
            DiscoveryPayloadUnion::GetNodes(_) => 1,
            DiscoveryPayloadUnion::Nodes(_) => 2,
            DiscoveryPayloadUnion::NotSet => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            DiscoveryPayloadUnion::GetNodes(_) => "GetNodes",
            DiscoveryPayloadUnion::Nodes(_) => "Nodes",
            DiscoveryPayloadUnion::NotSet => "NotSet",
        }
    }
    pub fn as_reader<'r>(&'r self) -> DiscoveryPayloadUnionReader<'r> {
        match self {
            DiscoveryPayloadUnion::GetNodes(item) => item.as_reader().into(),
            DiscoveryPayloadUnion::Nodes(item) => item.as_reader().into(),
            DiscoveryPayloadUnion::NotSet => DiscoveryPayloadUnionReader::NotSet,
        }
    }
}
impl<'r> DiscoveryPayloadUnionReader<'r> {
    pub const NAME: &'r str = "DiscoveryPayloadUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            DiscoveryPayloadUnionReader::GetNodes(item) => item.as_slice(),
            DiscoveryPayloadUnionReader::Nodes(item) => item.as_slice(),
            DiscoveryPayloadUnionReader::NotSet => &[],
        }
    }
    pub fn item_id(&self) -> molecule::ItemId {
        match self {
            DiscoveryPayloadUnionReader::GetNodes(_) => 1,
            DiscoveryPayloadUnionReader::Nodes(_) => 2,
            DiscoveryPayloadUnionReader::NotSet => 0,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            DiscoveryPayloadUnionReader::GetNodes(_) => "GetNodes",
            DiscoveryPayloadUnionReader::Nodes(_) => "Nodes",
            DiscoveryPayloadUnionReader::NotSet => "NotSet",
        }
    }
}
#[derive(Debug, Default)]
pub struct DiscoveryPayloadBuilder(pub(crate) DiscoveryPayloadUnion);
impl molecule::prelude::Entity for DiscoveryPayload {
    type Builder = DiscoveryPayloadBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        DiscoveryPayload(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DiscoveryPayloadReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DiscoveryPayloadReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
impl ::std::default::Default for DiscoveryPayload {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        DiscoveryPayload::new_unchecked(v.into())
    }
}
impl DiscoveryPayload {
    pub const NAME: &'static str = "DiscoveryPayload";
    pub fn as_reader<'r>(&'r self) -> DiscoveryPayloadReader<'r> {
        DiscoveryPayloadReader::new_unchecked(self.as_slice())
    }
    pub const ITEM_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::ItemId {
        molecule::extract_item_id(self.as_slice())
    }
    pub fn to_enum(&self) -> DiscoveryPayloadUnion {
        let inner = self.0.slice_from(molecule::ITEM_ID_SIZE);
        match self.item_id() {
            1 => GetNodes::new_unchecked(inner).into(),
            2 => Nodes::new_unchecked(inner).into(),
            0 => DiscoveryPayloadUnion::NotSet,
            _ => unreachable!(),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for DiscoveryPayloadReader<'r> {
    type Entity = DiscoveryPayload;
    fn to_entity(&self) -> Self::Entity {
        DiscoveryPayload::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DiscoveryPayloadReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        if slice.len() < molecule::ITEM_ID_SIZE {
            let err = VerificationError::HeaderIsBroken(
                Self::NAME.to_owned(),
                molecule::ITEM_ID_SIZE,
                slice.len(),
            );
            Err(err)?;
        }
        let item_id = molecule::extract_item_id(slice);
        match item_id {
            1 => GetNodesReader::verify(&slice[molecule::ITEM_ID_SIZE..], _compatible),
            2 => NodesReader::verify(&slice[molecule::ITEM_ID_SIZE..], _compatible),
            _ => {
                let err = VerificationError::UnknownItem(Self::NAME.to_owned(), 2, item_id);
                Err(err)
            }
        }?;
        Ok(())
    }
}
impl<'r> DiscoveryPayloadReader<'r> {
    pub const NAME: &'r str = "DiscoveryPayloadReader";
    pub const ITEM_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::ItemId {
        molecule::extract_item_id(self.as_slice())
    }
    pub fn to_enum(&self) -> DiscoveryPayloadUnionReader<'r> {
        let inner = &self.as_slice()[molecule::ITEM_ID_SIZE..];
        match self.item_id() {
            1 => GetNodesReader::new_unchecked(inner).into(),
            2 => NodesReader::new_unchecked(inner).into(),
            0 => DiscoveryPayloadUnionReader::NotSet,
            _ => unreachable!(),
        }
    }
}
impl molecule::prelude::Builder for DiscoveryPayloadBuilder {
    type Entity = DiscoveryPayload;
    fn expected_length(&self) -> usize {
        molecule::ITEM_ID_SIZE + self.0.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let item_id = self.0.item_id().to_le_bytes();
        writer.write_all(&item_id[..])?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        DiscoveryPayload::new_unchecked(inner.into())
    }
}
impl DiscoveryPayloadBuilder {
    pub const NAME: &'static str = "DiscoveryPayloadBuilder";
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::std::convert::Into<DiscoveryPayloadUnion>,
    {
        self.0 = v.into();
        self
    }
}
#[derive(Clone)]
pub struct DiscoveryMessage(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct DiscoveryMessageReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for DiscoveryMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for DiscoveryMessageReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for DiscoveryMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "payload", self.payload())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for DiscoveryMessageReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "payload", self.payload())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct DiscoveryMessageBuilder {
    pub(crate) payload: DiscoveryPayload,
}
impl ::std::default::Default for DiscoveryMessage {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        DiscoveryMessage::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for DiscoveryMessage {
    type Builder = DiscoveryMessageBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        DiscoveryMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DiscoveryMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DiscoveryMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().payload(self.payload())
    }
}
impl DiscoveryMessage {
    pub const NAME: &'static str = "DiscoveryMessage";
    pub fn as_reader<'r>(&'r self) -> DiscoveryMessageReader<'r> {
        DiscoveryMessageReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn payload(&self) -> DiscoveryPayload {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            DiscoveryPayload::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            DiscoveryPayload::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for DiscoveryMessageReader<'r> {
    type Entity = DiscoveryMessage;
    fn to_entity(&self) -> Self::Entity {
        DiscoveryMessage::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DiscoveryMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 1 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 1;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < expected {
            let err = VerificationError::FirstOffsetIsShort(
                Self::NAME.to_owned(),
                expected,
                offset_first,
            );
            Err(err)?;
        }
        let real_field_count = if compatible {
            let real_field_count = offset_first / 4 - 1;
            let real_expected = 4 + 4 * real_field_count;
            if total_size < real_expected {
                let err = VerificationError::DataIsShort(
                    Self::NAME.to_owned(),
                    real_expected,
                    total_size,
                );
                Err(err)?;
            }
            real_field_count
        } else {
            if offset_first > expected {
                let err = VerificationError::FirstOffsetIsOverflow(
                    Self::NAME.to_owned(),
                    expected,
                    offset_first,
                );
                Err(err)?;
            }
            1
        };
        let mut offsets: Vec<usize> = ptr[1..=real_field_count]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        DiscoveryPayloadReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
impl<'r> DiscoveryMessageReader<'r> {
    pub const NAME: &'r str = "DiscoveryMessageReader";
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn payload(&self) -> DiscoveryPayloadReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            DiscoveryPayloadReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            DiscoveryPayloadReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for DiscoveryMessageBuilder {
    type Entity = DiscoveryMessage;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 1 * 4;
        len_header + self.payload.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 1 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.payload.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.payload.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        DiscoveryMessage::new_unchecked(inner.into())
    }
}
impl DiscoveryMessageBuilder {
    pub const NAME: &'static str = "DiscoveryMessageBuilder";
    pub fn payload(mut self, v: DiscoveryPayload) -> Self {
        self.payload = v;
        self
    }
}
#[derive(Clone)]
pub struct GetNodes(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct GetNodesReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for GetNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for GetNodesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for GetNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "version", self.version())?;
        write!(f, ", {}: {}", "count", self.count())?;
        write!(f, ", {}: {}", "listen_port", self.listen_port())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 3 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for GetNodesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "version", self.version())?;
        write!(f, ", {}: {}", "count", self.count())?;
        write!(f, ", {}: {}", "listen_port", self.listen_port())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 3 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct GetNodesBuilder {
    pub(crate) version: Uint32,
    pub(crate) count: Uint32,
    pub(crate) listen_port: PortOpt,
}
impl ::std::default::Default for GetNodes {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            24, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        GetNodes::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for GetNodes {
    type Builder = GetNodesBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetNodes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetNodesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetNodesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .version(self.version())
            .count(self.count())
            .listen_port(self.listen_port())
    }
}
impl GetNodes {
    pub const NAME: &'static str = "GetNodes";
    pub fn as_reader<'r>(&'r self) -> GetNodesReader<'r> {
        GetNodesReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 3;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn version(&self) -> Uint32 {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        Uint32::new_unchecked(self.0.slice(start, end))
    }
    pub fn count(&self) -> Uint32 {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        let end = u32::from_le(offsets[1 + 1]) as usize;
        Uint32::new_unchecked(self.0.slice(start, end))
    }
    pub fn listen_port(&self) -> PortOpt {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[2]) as usize;
        if count == 3 {
            PortOpt::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[2 + 1]) as usize;
            PortOpt::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetNodesReader<'r> {
    type Entity = GetNodes;
    fn to_entity(&self) -> Self::Entity {
        GetNodes::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetNodesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 3 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 3;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < expected {
            let err = VerificationError::FirstOffsetIsShort(
                Self::NAME.to_owned(),
                expected,
                offset_first,
            );
            Err(err)?;
        }
        let real_field_count = if compatible {
            let real_field_count = offset_first / 4 - 1;
            let real_expected = 4 + 4 * real_field_count;
            if total_size < real_expected {
                let err = VerificationError::DataIsShort(
                    Self::NAME.to_owned(),
                    real_expected,
                    total_size,
                );
                Err(err)?;
            }
            real_field_count
        } else {
            if offset_first > expected {
                let err = VerificationError::FirstOffsetIsOverflow(
                    Self::NAME.to_owned(),
                    expected,
                    offset_first,
                );
                Err(err)?;
            }
            3
        };
        let mut offsets: Vec<usize> = ptr[1..=real_field_count]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        PortOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
impl<'r> GetNodesReader<'r> {
    pub const NAME: &'r str = "GetNodesReader";
    pub const FIELD_COUNT: usize = 3;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn version(&self) -> Uint32Reader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn count(&self) -> Uint32Reader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        let end = u32::from_le(offsets[1 + 1]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn listen_port(&self) -> PortOptReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[2]) as usize;
        if count == 3 {
            PortOptReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[2 + 1]) as usize;
            PortOptReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for GetNodesBuilder {
    type Entity = GetNodes;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 3 * 4;
        len_header
            + self.version.as_slice().len()
            + self.count.as_slice().len()
            + self.listen_port.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 3 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.version.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.count.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.listen_port.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.version.as_slice())?;
        writer.write_all(self.count.as_slice())?;
        writer.write_all(self.listen_port.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        GetNodes::new_unchecked(inner.into())
    }
}
impl GetNodesBuilder {
    pub const NAME: &'static str = "GetNodesBuilder";
    pub fn version(mut self, v: Uint32) -> Self {
        self.version = v;
        self
    }
    pub fn count(mut self, v: Uint32) -> Self {
        self.count = v;
        self
    }
    pub fn listen_port(mut self, v: PortOpt) -> Self {
        self.listen_port = v;
        self
    }
}
#[derive(Clone)]
pub struct Nodes(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct NodesReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Nodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for NodesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Nodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "announce", self.announce())?;
        write!(f, ", {}: {}", "items", self.items())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 2 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for NodesReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "announce", self.announce())?;
        write!(f, ", {}: {}", "items", self.items())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 2 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct NodesBuilder {
    pub(crate) announce: Bool,
    pub(crate) items: NodeVec,
}
impl ::std::default::Default for Nodes {
    fn default() -> Self {
        let v: Vec<u8> = vec![17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 4, 0, 0, 0];
        Nodes::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for Nodes {
    type Builder = NodesBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Nodes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .announce(self.announce())
            .items(self.items())
    }
}
impl Nodes {
    pub const NAME: &'static str = "Nodes";
    pub fn as_reader<'r>(&'r self) -> NodesReader<'r> {
        NodesReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 2;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn announce(&self) -> Bool {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        Bool::new_unchecked(self.0.slice(start, end))
    }
    pub fn items(&self) -> NodeVec {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        if count == 2 {
            NodeVec::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[1 + 1]) as usize;
            NodeVec::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for NodesReader<'r> {
    type Entity = Nodes;
    fn to_entity(&self) -> Self::Entity {
        Nodes::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NodesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 2 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 2;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < expected {
            let err = VerificationError::FirstOffsetIsShort(
                Self::NAME.to_owned(),
                expected,
                offset_first,
            );
            Err(err)?;
        }
        let real_field_count = if compatible {
            let real_field_count = offset_first / 4 - 1;
            let real_expected = 4 + 4 * real_field_count;
            if total_size < real_expected {
                let err = VerificationError::DataIsShort(
                    Self::NAME.to_owned(),
                    real_expected,
                    total_size,
                );
                Err(err)?;
            }
            real_field_count
        } else {
            if offset_first > expected {
                let err = VerificationError::FirstOffsetIsOverflow(
                    Self::NAME.to_owned(),
                    expected,
                    offset_first,
                );
                Err(err)?;
            }
            2
        };
        let mut offsets: Vec<usize> = ptr[1..=real_field_count]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        BoolReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        NodeVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
impl<'r> NodesReader<'r> {
    pub const NAME: &'r str = "NodesReader";
    pub const FIELD_COUNT: usize = 2;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn announce(&self) -> BoolReader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        BoolReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn items(&self) -> NodeVecReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        if count == 2 {
            NodeVecReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[1 + 1]) as usize;
            NodeVecReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for NodesBuilder {
    type Entity = Nodes;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 2 * 4;
        len_header + self.announce.as_slice().len() + self.items.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 2 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.announce.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.items.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.announce.as_slice())?;
        writer.write_all(self.items.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Nodes::new_unchecked(inner.into())
    }
}
impl NodesBuilder {
    pub const NAME: &'static str = "NodesBuilder";
    pub fn announce(mut self, v: Bool) -> Self {
        self.announce = v;
        self
    }
    pub fn items(mut self, v: NodeVec) -> Self {
        self.items = v;
        self
    }
}
#[derive(Clone)]
pub struct Node(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct NodeReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for NodeReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "addresses", self.addresses())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for NodeReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "addresses", self.addresses())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 1 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct NodeBuilder {
    pub(crate) addresses: BytesVec,
}
impl ::std::default::Default for Node {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0];
        Node::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for Node {
    type Builder = NodeBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Node(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NodeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().addresses(self.addresses())
    }
}
impl Node {
    pub const NAME: &'static str = "Node";
    pub fn as_reader<'r>(&'r self) -> NodeReader<'r> {
        NodeReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn addresses(&self) -> BytesVec {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            BytesVec::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            BytesVec::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for NodeReader<'r> {
    type Entity = Node;
    fn to_entity(&self) -> Self::Entity {
        Node::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NodeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 1 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 1;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < expected {
            let err = VerificationError::FirstOffsetIsShort(
                Self::NAME.to_owned(),
                expected,
                offset_first,
            );
            Err(err)?;
        }
        let real_field_count = if compatible {
            let real_field_count = offset_first / 4 - 1;
            let real_expected = 4 + 4 * real_field_count;
            if total_size < real_expected {
                let err = VerificationError::DataIsShort(
                    Self::NAME.to_owned(),
                    real_expected,
                    total_size,
                );
                Err(err)?;
            }
            real_field_count
        } else {
            if offset_first > expected {
                let err = VerificationError::FirstOffsetIsOverflow(
                    Self::NAME.to_owned(),
                    expected,
                    offset_first,
                );
                Err(err)?;
            }
            1
        };
        let mut offsets: Vec<usize> = ptr[1..=real_field_count]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        BytesVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
impl<'r> NodeReader<'r> {
    pub const NAME: &'r str = "NodeReader";
    pub const FIELD_COUNT: usize = 1;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn has_extra_fields(&self) -> bool {
        let (_, real_fields_count, _) = Self::field_offsets(self);
        Self::FIELD_COUNT == real_fields_count
    }
    pub fn addresses(&self) -> BytesVecReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        if count == 1 {
            BytesVecReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[0 + 1]) as usize;
            BytesVecReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for NodeBuilder {
    type Entity = Node;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 1 * 4;
        len_header + self.addresses.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 1 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.addresses.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.addresses.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        Node::new_unchecked(inner.into())
    }
}
impl NodeBuilder {
    pub const NAME: &'static str = "NodeBuilder";
    pub fn addresses(mut self, v: BytesVec) -> Self {
        self.addresses = v;
        self
    }
}
