// Generated by Molecule 0.2.5

use molecule::faster_hex::hex_string;
use molecule::prelude::{Entity as _, Reader as _};
#[derive(Clone)]
pub struct String(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct StringReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for StringReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Display for StringReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(&self.raw_data()).unwrap()
        )
    }
}
#[derive(Debug, Default)]
pub struct StringBuilder(pub(crate) Vec<u8>);
impl molecule::prelude::Entity for String {
    type Builder = StringBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        String(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StringReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for String {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        String::new_unchecked(v.into())
    }
}
impl String {
    pub const NAME: &'static str = "String";
    pub fn as_reader<'r>(&'r self) -> StringReader<'r> {
        StringReader::new_unchecked(self.as_slice())
    }
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice_from(4)
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl<'r> molecule::prelude::Reader<'r> for StringReader<'r> {
    type Entity = String;
    fn to_entity(&self) -> Self::Entity {
        String::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StringReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let item_count = u32::from_le(ptr[0]) as usize;
        let expected = 4 + 1 * item_count;
        if len != expected {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), expected, len);
            Err(err)?;
        }
        Ok(())
    }
}
impl<'r> StringReader<'r> {
    pub const NAME: &'r str = "StringReader";
    pub const ITEM_SIZE: usize = 1;
    pub fn len(&self) -> usize {
        let le = self.as_slice().as_ptr() as *const u32;
        u32::from_le(unsafe { *le }) as usize
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[4..]
    }
    pub fn get(&self, idx: usize) -> Option<u8> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> u8 {
        self.0[4 + idx]
    }
}
impl molecule::prelude::Builder for StringBuilder {
    type Entity = String;
    fn expected_length(&self) -> usize {
        4 + 1 * self.0.len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.0.len() as u32).to_le_bytes();
        writer.write_all(&len)?;
        writer.write_all(&self.0)?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        String::new_unchecked(inner.into())
    }
}
impl StringBuilder {
    pub const NAME: &'static str = "StringBuilder";
    pub fn set(mut self, v: Vec<u8>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: u8) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = u8>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct StringIterator(String, usize, usize);
impl ::std::iter::Iterator for StringIterator {
    type Item = u8;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for StringIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for String {
    type Item = u8;
    type IntoIter = StringIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        StringIterator(self, 0, len)
    }
}
#[derive(Clone)]
pub struct StringVec(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct StringVecReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for StringVec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for StringVecReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for StringVec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> ::std::fmt::Display for StringVecReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
#[derive(Debug, Default)]
pub struct StringVecBuilder(pub(crate) Vec<String>);
impl molecule::prelude::Entity for StringVec {
    type Builder = StringVecBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        StringVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        StringVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
impl ::std::default::Default for StringVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        StringVec::new_unchecked(v.into())
    }
}
impl StringVec {
    pub const NAME: &'static str = "StringVec";
    pub fn as_reader<'r>(&'r self) -> StringVecReader<'r> {
        StringVecReader::new_unchecked(self.as_slice())
    }
    pub fn offsets(&self) -> (usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        (bytes_len, &ptr[1..])
    }
    pub fn len(&self) -> usize {
        let (bytes_len, offsets) = self.offsets();
        if bytes_len == 4 {
            0
        } else {
            let first = u32::from_le(offsets[0]) as usize;
            (first - 4) / 4
        }
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<String> {
        let len = self.len();
        if idx >= len {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> String {
        let len = self.len();
        let (_, offsets) = self.offsets();
        let start = u32::from_le(offsets[idx]) as usize;
        if idx == len - 1 {
            String::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[idx + 1]) as usize;
            String::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for StringVecReader<'r> {
    type Entity = StringVec;
    fn to_entity(&self) -> Self::Entity {
        StringVec::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        StringVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if total_size == 4 {
            return Ok(());
        }
        if total_size < 4 + 4 {
            let err = VerificationError::DataIsShort(Self::NAME.to_owned(), 8, total_size);
            Err(err)?;
        }
        let offset_first = u32::from_le(ptr[1]) as usize;
        if offset_first % 4 != 0 {
            let err = VerificationError::FirstOffsetIsBroken(Self::NAME.to_owned(), offset_first);
            Err(err)?;
        }
        if offset_first < 4 + 4 {
            let err = VerificationError::FirstOffsetIsShort(Self::NAME.to_owned(), 8, offset_first);
            Err(err)?;
        }
        let item_count = offset_first / 4 - 1;
        let expected = 4 + 4 * item_count;
        if total_size < expected {
            let err = VerificationError::DataIsShort(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let mut offsets: Vec<usize> = ptr[1..(item_count + 1)]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        for i in 0..=(offsets.len() - 2) {
            let start = offsets[i];
            let end = offsets[i + 1];
            StringReader::verify(&slice[start..end])?;
        }
        Ok(())
    }
}
impl<'r> StringVecReader<'r> {
    pub const NAME: &'r str = "StringVecReader";
    pub fn offsets(&self) -> (usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        (bytes_len, &ptr[1..])
    }
    pub fn len(&self) -> usize {
        let (bytes_len, offsets) = self.offsets();
        if bytes_len == 4 {
            0
        } else {
            let first = u32::from_le(offsets[0]) as usize;
            (first - 4) / 4
        }
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<StringReader<'r>> {
        let len = self.len();
        if idx >= len {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> StringReader<'r> {
        let len = self.len();
        let (_, offsets) = self.offsets();
        let start = u32::from_le(offsets[idx]) as usize;
        if idx == len - 1 {
            StringReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[idx + 1]) as usize;
            StringReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for StringVecBuilder {
    type Entity = StringVec;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 4 * self.0.len();
        len_header
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 4 * self.0.len();
        for inner in &self.0[..] {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += inner.as_slice().len();
        }
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        StringVec::new_unchecked(inner.into())
    }
}
impl StringVecBuilder {
    pub const NAME: &'static str = "StringVecBuilder";
    pub fn set(mut self, v: Vec<String>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: String) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::std::iter::IntoIterator<Item = String>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
}
pub struct StringVecIterator(StringVec, usize, usize);
impl ::std::iter::Iterator for StringVecIterator {
    type Item = String;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::std::iter::ExactSizeIterator for StringVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::std::iter::IntoIterator for StringVec {
    type Item = String;
    type IntoIter = StringVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        StringVecIterator(self, 0, len)
    }
}
impl<'r> StringVecReader<'r> {
    pub fn iter<'t>(&'t self) -> StringVecReaderIterator<'t, 'r> {
        StringVecReaderIterator(&self, 0, self.len())
    }
}
pub struct StringVecReaderIterator<'t, 'r>(&'t StringVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::std::iter::Iterator for StringVecReaderIterator<'t, 'r> {
    type Item = StringReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::std::iter::ExactSizeIterator for StringVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct ProtocolInfo(molecule::bytes::Bytes);
#[derive(Clone, Copy)]
pub struct ProtocolInfoReader<'r>(&'r [u8]);
impl ::std::fmt::Debug for ProtocolInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl<'r> ::std::fmt::Debug for ProtocolInfoReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(
            f,
            "{}(0x{})",
            Self::NAME,
            hex_string(self.as_slice()).unwrap()
        )
    }
}
impl ::std::fmt::Display for ProtocolInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "support_versions", self.support_versions())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 2 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
impl<'r> ::std::fmt::Display for ProtocolInfoReader<'r> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "support_versions", self.support_versions())?;
        let (_, count, _) = Self::field_offsets(&self);
        if count != 2 {
            write!(f, ", ..")?;
        }
        write!(f, " }}")
    }
}
#[derive(Debug, Default)]
pub struct ProtocolInfoBuilder {
    pub(crate) name: String,
    pub(crate) support_versions: StringVec,
}
impl ::std::default::Default for ProtocolInfo {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
        ];
        ProtocolInfo::new_unchecked(v.into())
    }
}
impl molecule::prelude::Entity for ProtocolInfo {
    type Builder = ProtocolInfoBuilder;
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ProtocolInfo(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ProtocolInfoReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::std::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .name(self.name())
            .support_versions(self.support_versions())
    }
}
impl ProtocolInfo {
    pub const NAME: &'static str = "ProtocolInfo";
    pub fn as_reader<'r>(&'r self) -> ProtocolInfoReader<'r> {
        ProtocolInfoReader::new_unchecked(self.as_slice())
    }
    pub const FIELD_COUNT: usize = 2;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn name(&self) -> String {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        String::new_unchecked(self.0.slice(start, end))
    }
    pub fn support_versions(&self) -> StringVec {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        if count == 2 {
            StringVec::new_unchecked(self.0.slice_from(start))
        } else {
            let end = u32::from_le(offsets[1 + 1]) as usize;
            StringVec::new_unchecked(self.0.slice(start, end))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ProtocolInfoReader<'r> {
    type Entity = ProtocolInfo;
    fn to_entity(&self) -> Self::Entity {
        ProtocolInfo::new_unchecked(self.as_slice().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ProtocolInfoReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8]) -> molecule::error::VerificationResult<()> {
        use molecule::error::VerificationError;
        let len = slice.len();
        if len < 4 {
            let err = VerificationError::HeaderIsBroken(Self::NAME.to_owned(), 4, len);
            Err(err)?;
        }
        let ptr: &[u32] = unsafe { ::std::mem::transmute(slice) };
        let total_size = u32::from_le(ptr[0]) as usize;
        if total_size != len {
            let err = VerificationError::TotalSizeNotMatch(Self::NAME.to_owned(), total_size, len);
            Err(err)?;
        }
        if 2 == 0 && total_size == 4 {
            return Ok(());
        }
        let expected = 4 + 4 * 2;
        if total_size < expected {
            let err =
                VerificationError::HeaderIsBroken(Self::NAME.to_owned(), expected, total_size);
            Err(err)?;
        }
        let mut offsets: Vec<usize> = ptr[1..=2]
            .iter()
            .map(|x| u32::from_le(*x) as usize)
            .collect();
        if offsets[0] != expected {
            let err =
                VerificationError::FirstOffsetIsShort(Self::NAME.to_owned(), expected, offsets[0]);
            Err(err)?;
        }
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            let err = VerificationError::OffsetsNotMatch(Self::NAME.to_owned());
            Err(err)?;
        }
        StringReader::verify(&slice[offsets[0]..offsets[1]])?;
        StringVecReader::verify(&slice[offsets[1]..offsets[2]])?;
        Ok(())
    }
}
impl<'r> ProtocolInfoReader<'r> {
    pub const NAME: &'r str = "ProtocolInfoReader";
    pub const FIELD_COUNT: usize = 2;
    pub fn field_offsets(&self) -> (usize, usize, &[u32]) {
        let ptr: &[u32] = unsafe { ::std::mem::transmute(self.as_slice()) };
        let bytes_len = u32::from_le(ptr[0]) as usize;
        let first = u32::from_le(ptr[1]) as usize;
        let count = (first - 4) / 4;
        (bytes_len, count, &ptr[1..])
    }
    pub fn name(&self) -> StringReader<'r> {
        let (_, _, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[0]) as usize;
        let end = u32::from_le(offsets[0 + 1]) as usize;
        StringReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn support_versions(&self) -> StringVecReader<'r> {
        let (_, count, offsets) = Self::field_offsets(self);
        let start = u32::from_le(offsets[1]) as usize;
        if count == 2 {
            StringVecReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end = u32::from_le(offsets[1 + 1]) as usize;
            StringVecReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl molecule::prelude::Builder for ProtocolInfoBuilder {
    type Entity = ProtocolInfo;
    fn expected_length(&self) -> usize {
        let len_header = 4 + 2 * 4;
        len_header + self.name.as_slice().len() + self.support_versions.as_slice().len()
    }
    fn write<W: ::std::io::Write>(&self, writer: &mut W) -> ::std::io::Result<()> {
        let len = (self.expected_length() as u32).to_le_bytes();
        writer.write_all(&len[..])?;
        let mut offset = 4 + 2 * 4;
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.name.as_slice().len();
        }
        {
            let tmp = (offset as u32).to_le_bytes();
            writer.write_all(&tmp[..])?;
            offset += self.support_versions.as_slice().len();
        }
        let _ = offset;
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.support_versions.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner).expect("write vector should be ok");
        ProtocolInfo::new_unchecked(inner.into())
    }
}
impl ProtocolInfoBuilder {
    pub const NAME: &'static str = "ProtocolInfoBuilder";
    pub fn name(mut self, v: String) -> Self {
        self.name = v;
        self
    }
    pub fn support_versions(mut self, v: StringVec) -> Self {
        self.support_versions = v;
        self
    }
}
